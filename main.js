var _=Object.defineProperty;var z=Object.getOwnPropertyDescriptor;var j=Object.getOwnPropertyNames;var J=Object.prototype.hasOwnProperty;var Q=(h,t)=>{for(var e in t)_(h,e,{get:t[e],enumerable:!0})},X=(h,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of j(t))!J.call(h,n)&&n!==e&&_(h,n,{get:()=>t[n],enumerable:!(s=z(t,n))||s.enumerable});return h};var Y=h=>X(_({},"__esModule",{value:!0}),h);var Z={};Q(Z,{default:()=>D});module.exports=Y(Z);var v=require("obsidian");var k=require("obsidian"),x=class{constructor(t){this.refreshing=null;this.plugin=t}get baseUrl(){return this.plugin.settings.serverUrl}get accessToken(){return this.plugin.settings.accessToken}async register(){let t=this.plugin.settings;if(!t.username||!t.password)throw new Error("Username and password are required");let s=await this.request("POST","/api/auth/register",{username:t.username,password:t.password,device_name:`Obsidian (${this.getDeviceName()})`},!1);return await this.storeAuth(s),s}async login(){let t=this.plugin.settings;if(!t.username||!t.password)throw new Error("Username and password are required");let s=await this.request("POST","/api/auth/login",{username:t.username,password:t.password,device_name:`Obsidian (${this.getDeviceName()})`,device_type:"obsidian"},!1);return await this.storeAuth(s),s}async logout(){this.plugin.settings.refreshToken&&await this.request("POST","/api/auth/logout",{refresh_token:this.plugin.settings.refreshToken},!1),this.plugin.settings.accessToken="",this.plugin.settings.refreshToken="",this.plugin.settings.userId="",this.plugin.settings.deviceId="",await this.plugin.saveSettings()}async refreshTokens(){if(!this.plugin.settings.refreshToken)throw new Error("No refresh token available. Please log in again.");let e=await this.request("POST","/api/auth/refresh",{refresh_token:this.plugin.settings.refreshToken},!1);await this.storeAuth(e)}async storeAuth(t){this.plugin.settings.accessToken=t.access_token,this.plugin.settings.refreshToken=t.refresh_token,this.plugin.settings.userId=t.user_id,this.plugin.settings.deviceId=t.device_id,t.encryption_salt&&this.plugin.settings.encryptionSalt!==t.encryption_salt&&(this.plugin.settings.encryptionSalt=t.encryption_salt,this.plugin.crypto.clearCache()),await this.plugin.saveSettings()}async delta(t,e=[]){return await this.authRequest("POST","/api/sync/delta",{files:t,deleted_paths:e,vault_id:this.plugin.settings.vaultId||"default"})}async upload(t,e,s){return await this.authUpload("/api/sync/upload",t,e,s)}async download(t){return await this.authDownload(`/api/sync/download/${t}`)}async deleteFile(t){await this.authRequest("DELETE",`/api/sync/delete/${t}`)}async fixHash(t,e){await this.authRequest("POST","/api/sync/fix-hash",{file_id:t,hash:e})}async complete(){return await this.authRequest("POST","/api/sync/complete",{device_id:this.plugin.settings.deviceId})}async setVaultKey(t){await this.authRequest("PUT","/api/auth/vault-key",{encrypted_vault_key:t})}async pushEncryptionSalt(t,e=!1){await this.authRequest("PUT","/api/auth/encryption-salt",{salt:t,force:e})}async listFiles(t=!1){let e=t?"?include_deleted=true":"";return await this.authRequest("GET",`/api/files${e}`)}async fileVersions(t){return await this.authRequest("GET",`/api/files/${t}/versions`)}async rollback(t,e){return await this.authRequest("POST",`/api/files/${t}/rollback`,{version:e})}async listVaults(){return await this.authRequest("GET","/api/vaults")}async createVault(t){return await this.authRequest("POST","/api/vaults",{name:t})}async listDevices(){return await this.authRequest("GET","/api/devices")}async revokeDevice(t){await this.authRequest("DELETE",`/api/devices/${t}`)}async authRequest(t,e,s){try{return await this.request(t,e,s,!0)}catch(n){if(n instanceof P&&n.status===401)return await this.handleTokenRefresh(),await this.request(t,e,s,!0);throw n}}async authUpload(t,e,s,n){try{return await this.uploadRequest(t,e,s,n)}catch(i){if(i instanceof P&&i.status===401)return await this.handleTokenRefresh(),await this.uploadRequest(t,e,s,n);throw i}}async authDownload(t){try{return await this.downloadRequest(t)}catch(e){if(e instanceof P&&e.status===401)return await this.handleTokenRefresh(),await this.downloadRequest(t);throw e}}async handleTokenRefresh(){this.refreshing||(this.refreshing=this.refreshTokens().finally(()=>{this.refreshing=null})),await this.refreshing}async request(t,e,s,n=!0){let i={"Content-Type":"application/json"};n&&this.accessToken&&(i.Authorization=`Bearer ${this.accessToken}`);let a={url:`${this.baseUrl}${e}`,method:t,headers:i,throw:!1};s!==void 0&&(a.body=JSON.stringify(s));let c=await(0,k.requestUrl)(a);if(c.status>=400){let p=`HTTP ${c.status}`;try{let u=c.json;u&&u.error?p=u.error:u&&u.message&&(p=u.message)}catch{}throw new P(p,c.status)}return c.status===204||!c.text?{}:c.json}arrayBufferToBase64(t){let e=new Uint8Array(t),s="",n=8192;for(let i=0;i<e.length;i+=n)s+=String.fromCharCode(...e.subarray(i,i+n));return btoa(s)}async uploadRequest(t,e,s,n){let i={path:e,data:this.arrayBufferToBase64(s),vault_id:this.plugin.settings.vaultId||"default"};n&&(i.hash=n);let a={"Content-Type":"application/json"};this.accessToken&&(a.Authorization=`Bearer ${this.accessToken}`);let c=await(0,k.requestUrl)({url:`${this.baseUrl}${t}`,method:"POST",headers:a,body:JSON.stringify(i),throw:!1});if(c.status>=400){let p=`HTTP ${c.status}`;try{let u=c.json;u&&u.error?p=u.error:u&&u.message&&(p=u.message)}catch{try{let u=c.text?.slice(0,120);u&&(p=u)}catch{}}throw new P(p,c.status)}return c.json}async downloadRequest(t){let e={};this.accessToken&&(e.Authorization=`Bearer ${this.accessToken}`);let s=await(0,k.requestUrl)({url:`${this.baseUrl}${t}`,method:"GET",headers:e,throw:!1});if(s.status>=400){let n=`HTTP ${s.status}`;try{let i=s.json;i&&i.error?n=i.error:i&&i.message&&(n=i.message)}catch{}throw new P(n,s.status)}return s.arrayBuffer}getDeviceName(){try{if(typeof navigator<"u"&&navigator.userAgent){if(navigator.userAgent.includes("Windows"))return"Windows";if(navigator.userAgent.includes("Mac"))return"macOS";if(navigator.userAgent.includes("Linux"))return"Linux";if(navigator.userAgent.includes("Android"))return"Android";if(navigator.userAgent.includes("iPhone")||navigator.userAgent.includes("iPad"))return"iOS"}}catch{}return"Desktop"}isLoggedIn(){return!!this.plugin.settings.accessToken}},P=class extends Error{constructor(t,e){super(t),this.name="ApiError",this.status=e}};var A=class{constructor(){this.cachedKey=null;this.cachedPassphrase="";this.cachedSaltHex=""}async deriveKey(t,e){let s=new TextEncoder,n=await crypto.subtle.importKey("raw",s.encode(t),"PBKDF2",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:e.buffer,iterations:1e5,hash:"SHA-256"},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async getKey(t,e){if(this.cachedKey&&this.cachedPassphrase===t&&this.cachedSaltHex===e)return this.cachedKey;let s=M(e);return this.cachedKey=await this.deriveKey(t,s),this.cachedPassphrase=t,this.cachedSaltHex=e,this.cachedKey}generateSalt(){let t=new Uint8Array(16);return crypto.getRandomValues(t),N(t)}async encrypt(t,e,s){let n=await this.getKey(e,s),i=new Uint8Array(12);crypto.getRandomValues(i);let a=await crypto.subtle.encrypt({name:"AES-GCM",iv:i},n,t),c=new Uint8Array(12+a.byteLength);return c.set(i,0),c.set(new Uint8Array(a),12),c.buffer}async decrypt(t,e,s){let n=await this.getKey(e,s),i=new Uint8Array(t);if(i.byteLength<13)throw new Error("Encrypted data is too short");let a=i.slice(0,12),c=i.slice(12);try{return await crypto.subtle.decrypt({name:"AES-GCM",iv:a},n,c)}catch{throw new Error("Decryption failed. The passphrase may be incorrect or the data is corrupted.")}}clearCache(){this.cachedKey=null,this.cachedPassphrase="",this.cachedSaltHex=""}};function N(h){return Array.from(h).map(t=>t.toString(16).padStart(2,"0")).join("")}function M(h){let t=new Uint8Array(h.length/2);for(let e=0;e<h.length;e+=2)t[e/2]=parseInt(h.substring(e,e+2),16);return t}async function L(h,t){let e=new TextEncoder,s=await crypto.subtle.importKey("raw",e.encode(h),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e.encode(t),iterations:1e5,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function O(h,t){let e=new TextEncoder,s=new Uint8Array(12);crypto.getRandomValues(s);let n=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},t,e.encode(h)),i=new Uint8Array(12+n.byteLength);return i.set(s,0),i.set(new Uint8Array(n),12),N(i)}async function q(h,t){let e=M(h);if(e.length<13)throw new Error("Invalid vault key ciphertext");let s=e.slice(0,12),n=e.slice(12),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},t,n);return new TextDecoder().decode(i)}async function C(h){let t=await crypto.subtle.digest("SHA-256",h);return N(new Uint8Array(t))}var l=require("obsidian"),U=class extends l.AbstractInputSuggest{constructor(t,e,s,n){super(t,e),this.plugin=s,this.onSelect=n}getSuggestions(t){if(!t.trim())return[];let e=t.toLowerCase(),s=new Set(this.plugin.settings.excludePatterns),n=[];for(let i of this.plugin.app.vault.getAllLoadedFiles()){let a=i instanceof l.TFolder?i.path+"/":i.path;if(a.toLowerCase().includes(e)&&!s.has(a)&&(n.push(a),n.length>=20))break}return n}renderSuggestion(t,e){e.setText(t)}selectSuggestion(t,e){this.onSelect(t),this.setValue(""),this.close()}},H={serverUrl:"http://localhost:3000",username:"",password:"",autoSyncInterval:5,encryptionPassphrase:"",accessToken:"",refreshToken:"",userId:"",deviceId:"",encryptionSalt:"",lastSyncTime:0,excludePatterns:[],lastSyncedPaths:[],vaultId:"default",vaultName:""},V=class extends l.Modal{constructor(t,e){super(t),this.plugin=e}onOpen(){let{contentEl:t}=this;t.createEl("h2",{text:"Change Encryption Passphrase"}),t.createEl("p",{text:"Warning: this re-encrypts all files with the new passphrase. All other devices must update their passphrase before they can sync again.",attr:{style:"color: var(--text-muted); margin-bottom: 12px;"}});let e="",s="";new l.Setting(t).setName("New passphrase").addText(n=>{n.inputEl.type="password",n.setPlaceholder("Enter new passphrase\u2026"),n.onChange(i=>{e=i})}),new l.Setting(t).setName("Confirm passphrase").addText(n=>{n.inputEl.type="password",n.setPlaceholder("Confirm new passphrase\u2026"),n.onChange(i=>{s=i})}),new l.Setting(t).addButton(n=>n.setButtonText("Change Passphrase").setWarning().onClick(async()=>{if(!e){new l.Notice("CloudSync: Passphrase cannot be empty");return}if(e!==s){new l.Notice("CloudSync: Passphrases do not match");return}this.close();try{await this.plugin.changePassphrase(e),new l.Notice("CloudSync: Passphrase changed. Re-uploading all files\u2026")}catch(i){let a=i instanceof Error?i.message:String(i);new l.Notice(`CloudSync: Passphrase change failed \u2014 ${a}`)}})).addButton(n=>n.setButtonText("Cancel").onClick(()=>this.close()))}onClose(){this.contentEl.empty()}},K=class extends l.Modal{constructor(t,e,s){super(t),this.plugin=e,this.onConfirm=s}onOpen(){let{contentEl:t}=this;t.createEl("h2",{text:"Create New Vault"}),t.createEl("p",{text:"Give your vault a name. Each vault is a separate file namespace \u2014 files in one vault are not visible to other vaults."});let e="";new l.Setting(t).setName("Vault name").addText(s=>{s.setPlaceholder("e.g. Personal, Work, Archive\u2026"),s.onChange(n=>{e=n}),s.inputEl.addEventListener("keydown",async n=>{n.key==="Enter"&&e.trim()&&(this.close(),await this.onConfirm(e.trim()))}),setTimeout(()=>s.inputEl.focus(),50)}),new l.Setting(t).addButton(s=>s.setButtonText("Create").setCta().onClick(async()=>{if(!e.trim()){new l.Notice("CloudSync: Vault name cannot be empty");return}this.close(),await this.onConfirm(e.trim())})).addButton(s=>s.setButtonText("Cancel").onClick(()=>this.close()))}onClose(){this.contentEl.empty()}},B=class extends l.PluginSettingTab{constructor(t,e){super(t,e),this.plugin=e}async display(){let{containerEl:t}=this;t.empty(),t.addClass("cloudsync-settings"),t.createEl("h2",{text:"CloudSync Settings"});let e=!!this.plugin.settings.accessToken;if(t.createDiv({cls:`connection-status ${e?"connected":"disconnected"}`}).setText(e?`Connected as ${this.plugin.settings.username} (Device: ${this.plugin.settings.deviceId.substring(0,8)}...)`:"Not connected"),t.createEl("h3",{text:"Server"}),new l.Setting(t).setName("Server URL").setDesc("The URL of your ObsidianCloudSync server").addText(r=>r.setPlaceholder("http://localhost:3000").setValue(this.plugin.settings.serverUrl).onChange(async o=>{this.plugin.settings.serverUrl=o.replace(/\/+$/,""),await this.plugin.saveSettings()})),t.createEl("h3",{text:"Authentication"}),new l.Setting(t).setName("Username").addText(r=>r.setPlaceholder("username").setValue(this.plugin.settings.username).onChange(async o=>{this.plugin.settings.username=o,await this.plugin.saveSettings()})),new l.Setting(t).setName("Password").addText(r=>{r.inputEl.type="password",r.setPlaceholder("password").setValue(this.plugin.settings.password).onChange(async o=>{this.plugin.settings.password=o,await this.plugin.saveSettings()})}),new l.Setting(t).setName("Account").addButton(r=>r.setButtonText("Login").onClick(async()=>{try{let o=await this.plugin.api.login();await this.plugin.handleVaultKeyFromAuth(o),await this.plugin.autoSelectVault(),new l.Notice("CloudSync: Logged in successfully"),this.display()}catch(o){let g=o instanceof Error?o.message:String(o);new l.Notice(`CloudSync: Login failed \u2014 ${g}`)}})).addButton(r=>r.setButtonText("Register").onClick(async()=>{try{await this.plugin.api.register(),await this.plugin.autoSelectVault(),new l.Notice("CloudSync: Registered and logged in"),this.display()}catch(o){let g=o instanceof Error?o.message:String(o);new l.Notice(`CloudSync: Registration failed \u2014 ${g}`)}})),e&&new l.Setting(t).setName("Session").setDesc("Clears stored tokens from this device").addButton(r=>r.setButtonText("Logout").setWarning().onClick(async()=>{try{await this.plugin.api.logout()}catch{}this.plugin.settings.accessToken="",this.plugin.settings.refreshToken="",this.plugin.settings.userId="",this.plugin.settings.deviceId="",await this.plugin.saveSettings(),this.plugin.wsClient?.disconnect(),new l.Notice("CloudSync: Logged out"),this.display()})),e){t.createEl("h3",{text:"Vault"});let r=[];try{r=await this.plugin.api.listVaults(),r.length>0&&!this.plugin.settings.vaultId&&(this.plugin.settings.vaultId=r[0].id,this.plugin.settings.vaultName=r[0].name,await this.plugin.saveSettings())}catch{}let o=new l.Setting(t).setName("Active vault").setDesc("Files sync to the selected vault. Each vault is isolated \u2014 switching vaults shows different files.");r.length>0?o.addDropdown(g=>{for(let f of r)g.addOption(f.id,f.name);g.setValue(this.plugin.settings.vaultId||r[0].id),g.onChange(async f=>{let m=r.find(E=>E.id===f);this.plugin.settings.vaultId=f,this.plugin.settings.vaultName=m?.name??f,this.plugin.settings.lastSyncTime=0,this.plugin.settings.lastSyncedPaths=[],await this.plugin.saveSettings(),new l.Notice(`CloudSync: Switched to vault "${m?.name??f}"`)})}):this.plugin.settings.vaultName&&o.setDesc(`Active vault: ${this.plugin.settings.vaultName} (offline)`),o.addButton(g=>g.setButtonText("+ New vault").onClick(()=>{new K(this.app,this.plugin,async f=>{try{let m=await this.plugin.api.createVault(f);this.plugin.settings.vaultId=m.id,this.plugin.settings.vaultName=m.name,this.plugin.settings.lastSyncTime=0,this.plugin.settings.lastSyncedPaths=[],await this.plugin.saveSettings(),new l.Notice(`CloudSync: Created and switched to vault "${m.name}"`),this.display()}catch(m){let E=m instanceof Error?m.message:String(m);new l.Notice(`CloudSync: Failed to create vault \u2014 ${E}`)}}).open()}))}t.createEl("h3",{text:"Encryption"});let n=!!this.plugin.settings.encryptionSalt,i=!!this.plugin.settings.encryptionPassphrase;n&&i?new l.Setting(t).setName("Encryption").setDesc("Active \u2014 files are encrypted with AES-256-GCM before leaving this device. The encryption key is synced automatically from your account."):n&&!i?new l.Setting(t).setName("Encryption \u2014 key not loaded").setDesc("The server has encryption configured but the key hasn't loaded on this device. Log out and log back in to load it automatically, or click 'Load from account'.").addButton(r=>r.setButtonText("Load from account").setCta().onClick(async()=>{try{let o=await this.plugin.api.login();await this.plugin.handleVaultKeyFromAuth(o),this.display()}catch(o){let g=o instanceof Error?o.message:String(o);new l.Notice(`CloudSync: Could not load encryption key \u2014 ${g}`)}})):new l.Setting(t).setName("Encryption").setDesc("Not configured \u2014 files are synced without encryption. To enable encryption, see the Advanced section below."),t.createEl("h3",{text:"Sync"}),new l.Setting(t).setName("Auto-sync").setDesc("When to automatically sync changes to the server.").addDropdown(r=>r.addOption("0","Disabled").addOption("-1","Only on change").addOption("5","Every 5 minutes").addOption("10","Every 10 minutes").addOption("15","Every 15 minutes").addOption("30","Every 30 minutes").addOption("60","Every hour").setValue(String(this.plugin.settings.autoSyncInterval)).onChange(async o=>{this.plugin.settings.autoSyncInterval=parseInt(o,10),await this.plugin.saveSettings(),this.plugin.restartAutoSync()})),this.plugin.settings.lastSyncTime>0?new l.Setting(t).setName("Last sync").setDesc(new Date(this.plugin.settings.lastSyncTime).toLocaleString()).addButton(r=>r.setButtonText("Sync now").onClick(async()=>{await this.plugin.syncNow()})):new l.Setting(t).setName("Manual sync").addButton(r=>r.setButtonText("Sync now").onClick(async()=>{await this.plugin.syncNow()})),new l.Setting(t).setName("Directional sync").setDesc("Push: upload local files to server \u2014 local wins on conflicts, server changes are ignored. Pull: download server files to local \u2014 server wins on conflicts, local uploads are skipped. Use Push when you paste files locally that have older timestamps and don't want them overwritten.").addButton(r=>r.setButtonText("Push only").onClick(async()=>{await this.plugin.pushNow()})).addButton(r=>r.setButtonText("Pull only").onClick(async()=>{await this.plugin.pullNow()})),new l.Setting(t).setName("Repair server files").setDesc("Re-uploads all local files to the server using the current encryption key. Use this if files on the server cannot be decrypted on other devices (e.g., uploaded via a proxy that corrupted the encrypted data). Only files present on this device are repaired.").addButton(r=>r.setButtonText("Force re-upload all").setWarning().onClick(async()=>{try{await this.plugin.syncEngine.reEncryptLocal(),new l.Notice("CloudSync: Re-upload complete. Files should now be decryptable on all devices.")}catch(o){let g=o instanceof Error?o.message:String(o);new l.Notice(`CloudSync: Re-upload failed \u2014 ${g}`)}})),t.createEl("h3",{text:"Exclude from sync"});let a=t.createDiv({cls:"cloudsync-chip-list"});this.renderChips(a);let c;new l.Setting(t).setName("Add exclusion").setDesc("Search vault files and folders, or type a glob pattern (e.g. *.tmp) and press Enter.").addText(r=>{r.setPlaceholder("Search files and folders\u2026"),c=r,new U(this.app,r.inputEl,this.plugin,async o=>{await this.addPattern(o,a)}),r.inputEl.addEventListener("keydown",async o=>{if(o.key==="Enter"){let g=r.getValue().trim();g&&(await this.addPattern(g,a),r.setValue(""))}})});let p=t.createEl("details");p.createEl("summary",{text:"Advanced"});let u=p.createDiv();new l.Setting(u).setName("Change encryption passphrase").setDesc("Generates a new encryption key and re-uploads all local files. Other devices will need to log out and log back in to receive the new key automatically.").addButton(r=>r.setButtonText("Change Passphrase").setWarning().onClick(()=>{new V(this.plugin.app,this.plugin).open()})),!i&&!n&&new l.Setting(u).setName("Set encryption passphrase").setDesc("Enable client-side encryption for this account. Leave empty to sync without encryption. Once set, all devices on this account will encrypt files automatically.").addText(r=>{r.inputEl.type="password",r.setPlaceholder("Enter a passphrase\u2026").setValue(this.plugin.settings.encryptionPassphrase).onChange(async o=>{this.plugin.settings.encryptionPassphrase=o,await this.plugin.saveSettings(),this.plugin.pushVaultKey()})})}async addPattern(t,e){this.plugin.settings.excludePatterns.includes(t)||(this.plugin.settings.excludePatterns.push(t),await this.plugin.saveSettings(),this.renderChips(e))}renderChips(t){if(t.empty(),this.plugin.settings.excludePatterns.length===0){t.createEl("div",{text:"No exclusions added.",cls:"cloudsync-chip-empty"});return}for(let e of[...this.plugin.settings.excludePatterns]){let s=t.createDiv({cls:"cloudsync-chip"});s.createEl("span",{text:e,cls:"cloudsync-chip-text"});let n=s.createEl("button",{cls:"cloudsync-chip-remove",text:"\xD7"});n.setAttribute("aria-label",`Remove ${e}`),n.addEventListener("click",async()=>{this.plugin.settings.excludePatterns=this.plugin.settings.excludePatterns.filter(i=>i!==e),await this.plugin.saveSettings(),this.renderChips(t)})}}};var $=class{constructor(t,e){this.state="idle";this.message="";this.progress="";this.ticker=null;this.plugin=t,this.statusBarEl=e,this.ticker=setInterval(()=>{this.state==="idle"&&this.render()},3e4),this.render()}destroy(){this.ticker!==null&&(clearInterval(this.ticker),this.ticker=null)}setState(t,e){this.state=t,this.message=e||"",this.progress="",this.render()}setProgress(t,e,s){this.state="syncing",this.progress=`${t}/${e}`,this.message=s||"",this.render()}render(){this.statusBarEl.empty(),this.statusBarEl.addClass("cloudsync-status-bar"),this.statusBarEl.createSpan({cls:`sync-icon ${this.state}`}).setAttribute("aria-label",this.state);let e;switch(this.state){case"idle":this.plugin.settings.lastSyncTime>0?e=`Synced ${this.timeAgo(this.plugin.settings.lastSyncTime)}`:e="CloudSync: Ready";break;case"syncing":this.progress?e=`Syncing ${this.progress} files...`:e=this.message||"Syncing...";break;case"error":e=this.message||"Sync error";break}this.statusBarEl.createSpan({text:e})}timeAgo(t){let s=Date.now()-t,n=Math.floor(s/1e3);if(n<60)return"just now";let i=Math.floor(n/60);if(i<60)return`${i}m ago`;let a=Math.floor(i/60);return a<24?`${a}h ago`:`${Math.floor(a/24)}d ago`}};var w=require("obsidian");var I=class{constructor(t){this.syncing=!1;this.hashCache=new Map;this.dirty=!1;this.plugin=t}get isSyncing(){return this.syncing}get isDirty(){return this.dirty}markDirty(){this.dirty=!0}async sync(t=!1,e="bidirectional"){if(this.syncing){t||new w.Notice("CloudSync: Sync already in progress");return}if(!this.plugin.api.isLoggedIn()){t||new w.Notice("CloudSync: Not logged in. Please log in first.");return}this.syncing=!0,this.plugin.statusBar.setState("syncing","Building manifest...");try{let s=await this.buildManifest();this.plugin.statusBar.setState("syncing",`Checking ${s.length} files...`);let n=new Set(s.map(d=>d.path)),i=this.plugin.settings.lastSyncedPaths??[],a=[];if(i.length>0){let d=i.filter(b=>!n.has(b)),y=d.length/i.length;y<=.5?a.push(...d):console.warn(`CloudSync: ${d.length}/${i.length} tracked files appear deleted \u2014 ratio ${(y*100).toFixed(0)}% exceeds 50% threshold, skipping explicit deletes (treating as possible vault wipe; server will send Download instructions instead)`)}let c=e==="pull"?[]:a,p=await this.plugin.api.delta(s,c);await this.reconcileEncryptionSalt(p.encryption_salt);let u=e==="push"?p.instructions.filter(d=>d.action==="upload"||d.action==="conflict"):e==="pull"?p.instructions.filter(d=>d.action==="download"||d.action==="delete"||d.action==="conflict"):p.instructions;if(u.length===0){await this.plugin.api.complete(),this.plugin.settings.lastSyncTime=Date.now(),this.plugin.settings.lastSyncedPaths=s.map(d=>d.path),await this.plugin.saveSettings(),this.dirty=!1,this.plugin.statusBar.setState("idle");return}let r=0,o=0,g=0,f=0,m=0,E=0,T=u.length;for(let d=0;d<u.length;d++){let y=u[d];try{switch(y.action){case"upload":this.plugin.statusBar.setProgress(d+1,T,`Uploading: ${y.path}`),await this.withRetry(()=>this.handleUpload(y),y.path),r++;break;case"download":this.plugin.statusBar.setProgress(d+1,T,`Downloading: ${y.path}`),await this.handleDownload(y)&&o++;break;case"conflict":this.plugin.statusBar.setProgress(d+1,T,`Resolving conflict: ${y.path}`),e==="push"?(await this.withRetry(()=>this.handleUpload(y),y.path),r++):e==="pull"?await this.handleDownload(y)&&o++:(await this.handleConflict(y),f++);break;case"delete":this.plugin.statusBar.setProgress(d+1,T,`Deleting: ${y.path}`),await this.handleDelete(y),g++;break}}catch(b){m++,(y.action==="download"||y.action==="conflict")&&E++;let G=b instanceof Error?b.message:String(b),F=b.status,W=F?`[HTTP ${F}] `:"";console.error(`CloudSync: Error processing ${y.path}: ${W}${G}`)}}E===0?(await this.plugin.api.complete(),this.plugin.settings.lastSyncTime=Date.now(),this.plugin.settings.lastSyncedPaths=s.map(d=>d.path),await this.plugin.saveSettings(),this.dirty=!1):console.warn(`CloudSync: ${E} download(s) failed \u2014 skipping complete() so the sync cursor is not advanced. Will retry on next sync.`);let S=[];if(r>0&&S.push(`${r} uploaded`),o>0&&S.push(`${o} downloaded`),g>0&&S.push(`${g} deleted`),f>0&&S.push(`${f} conflicts`),m>0&&S.push(`${m} errors`),!t||S.length>0){let d=S.length>0?S.join(", "):"no changes",y=e==="push"?"Push":e==="pull"?"Pull":"Sync";new w.Notice(`CloudSync: ${y} complete (${d})`)}this.plugin.statusBar.setState("idle")}catch(s){let n=s instanceof Error?s.message:String(s);console.error("CloudSync: Sync failed:",n),new w.Notice(`CloudSync: Sync failed - ${n}`),this.plugin.statusBar.setState("error",`Error: ${n}`)}finally{this.syncing=!1}}async buildManifest(){let t=this.plugin.app.vault,e=t.getFiles(),s=[],n=new Set,i=0;for(let a of e){if(this.shouldSkip(a.path))continue;n.add(a.path);let c=Math.floor(a.stat.mtime/1e3),p=a.stat.size,u=this.hashCache.get(a.path);if(u&&u.mtime===c&&u.size===p){s.push({path:a.path,hash:u.hash,size:u.size,modified_at:c}),i++;continue}try{let r=await t.readBinary(a),o=await C(r);this.hashCache.set(a.path,{hash:o,mtime:c,size:r.byteLength}),s.push({path:a.path,hash:o,size:r.byteLength,modified_at:c})}catch(r){let o=r instanceof Error?r.message:String(r);console.warn(`CloudSync: Could not read ${a.path}: ${o}`)}}for(let a of this.hashCache.keys())n.has(a)||this.hashCache.delete(a);return console.log(`CloudSync: Manifest built \u2014 ${s.length} files, ${i} cached, ${s.length-i} hashed`),s}async handleUpload(t){let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);if(!(s instanceof w.TFile))throw new Error(`File not found in vault: ${t.path}`);let n=await e.readBinary(s),i=await C(n),a;this.isEncryptionEnabled()?a=await this.plugin.crypto.encrypt(n,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt):a=n,await this.plugin.api.upload(t.path,a,i)}async handleDownload(t){if(!t.file_id)throw new Error(`No file_id for download: ${t.path}`);if(this.plugin.settings.encryptionSalt&&!this.plugin.settings.encryptionPassphrase)throw new Error(`Cannot download "${t.path}" \u2014 server has encryption configured but no passphrase is set on this device. Enter your encryption passphrase in plugin settings.`);let e=await this.plugin.api.download(t.file_id),s;if(this.isEncryptionEnabled())try{s=await this.plugin.crypto.decrypt(e,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt)}catch(c){let p=await C(e),u=this.plugin.app.vault,r=(0,w.normalizePath)(t.path),o=u.getAbstractFileByPath(r);if(o instanceof w.TFile){let g=await u.readBinary(o),f=await C(g);if(f===p)return console.warn(`CloudSync: Decryption skipped for "${t.path}" \u2014 blob matches local content (uploaded before encryption was enabled). Fixing server hash.`),await this.plugin.api.fixHash(t.file_id,f),!1}if(t.server_hash&&p===t.server_hash)console.warn(`CloudSync: Using plaintext blob for "${t.path}" \u2014 file was uploaded before encryption was enabled.`),s=e;else throw c}else s=e;let n=this.plugin.app.vault,i=(0,w.normalizePath)(t.path),a=n.getAbstractFileByPath(i);if(a instanceof w.TFile){let c;try{c=await n.readBinary(a)}catch{return console.warn(`CloudSync: Could not read "${t.path}" for comparison (file may be locked) \u2014 skipping`),!1}let p=await C(c),u=await C(s);return p===u?(await this.plugin.api.fixHash(t.file_id,p),!1):(await n.modifyBinary(a,s),!0)}return await this.ensureDirectory(i),await n.createBinary(i,s),!0}async handleConflict(t){if(t.file_id){let n=await this.plugin.api.download(t.file_id);this.isEncryptionEnabled()&&(n=await this.plugin.crypto.decrypt(n,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt));let i=this.makeConflictPath(t.path);await this.ensureDirectory(i);let a=this.plugin.app.vault,c=a.getAbstractFileByPath(i);c instanceof w.TFile?await a.modifyBinary(c,n):await a.createBinary(i,n),new w.Notice(`CloudSync: Conflict on "${t.path}" - server version saved as "${i}"`)}let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);if(s instanceof w.TFile){let n=await e.readBinary(s),i=await C(n),a=n;this.isEncryptionEnabled()&&(a=await this.plugin.crypto.encrypt(n,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt)),await this.plugin.api.upload(t.path,a,i)}}async handleDelete(t){let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);s instanceof w.TFile&&await e.delete(s)}makeConflictPath(t){let e=new Date().toISOString().replace(/[:.]/g,"-").slice(0,19),s=t.lastIndexOf(".");if(s===-1)return`${t}.conflict-${e}`;let n=t.substring(0,s),i=t.substring(s);return`${n}.conflict-${e}${i}`}async ensureDirectory(t){let e=t.split("/");if(e.length<=1)return;let s=e.slice(0,-1).join("/"),n=this.plugin.app.vault;n.getAbstractFileByPath(s)||await n.createFolder(s)}shouldSkip(t){if(t.startsWith(".")||t==="data.json")return!0;for(let e of this.plugin.settings.excludePatterns)if(this.matchesPattern(t,e))return!0;return!1}matchesPattern(t,e){if(e.endsWith("/"))return t.startsWith(e)||t.startsWith(e.slice(0,-1));if(t===e)return!0;let s="^";for(let n=0;n<e.length;n++){let i=e[n];i==="*"&&e[n+1]==="*"?(s+=".*",n++,e[n+1]==="/"&&n++):i==="*"?s+="[^/]*":i==="?"||i==="."||i==="("||i===")"||i==="["||i==="]"||i==="{"||i==="}"||i==="+"||i==="^"||i==="$"||i==="|"||i==="\\"?s+="\\"+i:s+=i}s+="$";try{return new RegExp(s).test(t)}catch{return!1}}async withRetry(t,e,s=3){let n;for(let i=1;i<=s;i++)try{return await t()}catch(a){n=a;let c=a.status;if(c===401||c===403||c===404||c===413)throw a;if(i<s){let p=i*2e3;console.warn(`CloudSync: Upload attempt ${i} failed for ${e} \u2014 retrying in ${p/1e3}s`),await new Promise(u=>setTimeout(u,p))}}throw n}async reEncryptLocal(){if(this.syncing)throw new Error("Sync already in progress");if(!this.plugin.api.isLoggedIn())throw new Error("Not logged in");this.syncing=!0,this.plugin.statusBar.setState("syncing","Re-encrypting files...");try{let t=await this.buildManifest(),e=0,s=0,n=t.length;for(let i=0;i<t.length;i++){let a=t[i];this.plugin.statusBar.setProgress(i+1,n,`Re-encrypting: ${a.path}`);let c={path:a.path,action:"upload",file_id:null,server_hash:null,server_modified_at:null};try{await this.withRetry(()=>this.handleUpload(c),a.path),e++}catch(p){s++;let u=p instanceof Error?p.message:String(p);console.error(`CloudSync: Re-encrypt failed for ${a.path}: ${u}`)}}console.log(`CloudSync: Re-encrypted ${e} local file(s)${s>0?`, ${s} error(s)`:""}`)}finally{this.syncing=!1,this.plugin.statusBar.setState("idle")}}async reconcileEncryptionSalt(t){if(t)this.plugin.settings.encryptionSalt!==t&&(this.plugin.settings.encryptionSalt=t,this.plugin.crypto.clearCache(),await this.plugin.saveSettings()),this.plugin.settings.encryptionPassphrase&&this.plugin.pushVaultKey();else if(this.plugin.settings.encryptionPassphrase){this.plugin.settings.encryptionSalt||(this.plugin.settings.encryptionSalt=this.plugin.crypto.generateSalt(),await this.plugin.saveSettings());try{await this.plugin.api.pushEncryptionSalt(this.plugin.settings.encryptionSalt),this.plugin.pushVaultKey()}catch{}}}isEncryptionEnabled(){return!!this.plugin.settings.encryptionPassphrase&&!!this.plugin.settings.encryptionSalt}};var R=class{constructor(t){this.ws=null;this.reconnectTimer=null;this.reconnectDelay=1e3;this.maxReconnectDelay=3e4;this.alive=!1;this.plugin=t}connect(){if(!this.plugin.api.isLoggedIn())return;let t=this.plugin.settings.serverUrl,e=this.plugin.settings.accessToken,n=`${t.replace(/^https:\/\//,"wss://").replace(/^http:\/\//,"ws://")}/api/ws?token=${encodeURIComponent(e)}`;try{this.ws=new WebSocket(n),this.alive=!0,this.ws.onopen=()=>{console.log("CloudSync WS: Connected"),this.reconnectDelay=1e3},this.ws.onmessage=i=>{this.handleMessage(i.data)},this.ws.onclose=i=>{console.log(`CloudSync WS: Closed (code=${i.code}, reason=${i.reason})`),this.ws=null,this.alive&&this.scheduleReconnect()},this.ws.onerror=()=>{console.warn("CloudSync WS: Connection error")}}catch(i){console.warn("CloudSync WS: Failed to connect:",i),this.scheduleReconnect()}}disconnect(){this.alive=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.ws&&(this.ws.close(),this.ws=null)}handleMessage(t){try{let e=JSON.parse(t);e.type==="sync_update"&&(console.log(`CloudSync WS: Sync update - ${e.action} ${e.file_path}`),this.plugin.syncEngine.isSyncing||setTimeout(()=>{this.plugin.syncEngine.isSyncing||this.plugin.syncNow()},2e3))}catch{}}scheduleReconnect(){this.alive&&(console.log(`CloudSync WS: Reconnecting in ${this.reconnectDelay/1e3}s...`),this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=null,this.connect()},this.reconnectDelay),this.reconnectDelay=Math.min(this.reconnectDelay*2,this.maxReconnectDelay))}get isConnected(){return this.ws!==null&&this.ws.readyState===WebSocket.OPEN}};var D=class extends v.Plugin{constructor(e,s){super(e,s);this.autoSyncTimer=null;this.debouncedSync=(0,v.debounce)(()=>{this.api.isLoggedIn()&&!this.syncEngine.isSyncing&&this.syncEngine.sync(!0)},3e3,!0)}async onload(){console.log("CloudSync: Loading plugin"),await this.loadSettings(),this.api=new x(this),this.crypto=new A,this.syncEngine=new I(this),this.wsClient=new R(this);let e=this.addStatusBarItem();this.statusBar=new $(this,e),this.addSettingTab(new B(this.app,this)),this.addRibbonIcon("refresh-cw","CloudSync: Sync now",async()=>{await this.syncNow()}),this.addCommand({id:"cloudsync-sync-now",name:"Sync now (bidirectional)",callback:async()=>{await this.syncNow()}}),this.addCommand({id:"cloudsync-push-now",name:"Push now (upload local changes to server)",callback:async()=>{await this.pushNow()}}),this.addCommand({id:"cloudsync-pull-now",name:"Pull now (download server changes to local)",callback:async()=>{await this.pullNow()}}),this.addCommand({id:"cloudsync-view-status",name:"View sync status",callback:()=>{this.showSyncStatus()}});let s=n=>{n instanceof v.TFile&&!n.path.startsWith(".obsidian/")&&!this.syncEngine.isSyncing&&(this.syncEngine.markDirty(),this.settings.autoSyncInterval!==0&&this.debouncedSync())};this.registerEvent(this.app.vault.on("modify",s)),this.registerEvent(this.app.vault.on("create",s)),this.registerEvent(this.app.vault.on("delete",s)),this.registerEvent(this.app.vault.on("rename",s)),this.restartAutoSync(),this.api.isLoggedIn()&&(setTimeout(()=>{this.syncNow()},5e3),this.wsClient.connect())}async onunload(){console.log("CloudSync: Unloading plugin"),this.stopAutoSync(),this.statusBar.destroy(),this.wsClient.disconnect()}async loadSettings(){this.settings=Object.assign({},H,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}async syncNow(){await this.syncEngine.sync()}async pushNow(){await this.syncEngine.sync(!1,"push")}async pullNow(){await this.syncEngine.sync(!1,"pull")}showSyncStatus(){let e=this.settings,s=[];this.api.isLoggedIn()?(s.push(`Logged in as: ${e.username}`),s.push(`Device ID: ${e.deviceId.substring(0,8)}...`)):s.push("Not logged in"),e.lastSyncTime>0?s.push(`Last sync: ${new Date(e.lastSyncTime).toLocaleString()}`):s.push("Never synced");let n=e.autoSyncInterval===-1?"only on change":e.autoSyncInterval===0?"disabled":`every ${e.autoSyncInterval} min`;s.push(`Auto-sync: ${n}`),s.push(`Encryption: ${e.encryptionPassphrase?"enabled":"disabled"}`),this.syncEngine.isSyncing?s.push("Status: Syncing..."):s.push("Status: Idle"),new v.Notice(s.join(`
`),1e4)}restartAutoSync(){if(this.stopAutoSync(),this.settings.autoSyncInterval>0){let e=this.settings.autoSyncInterval*60*1e3;this.autoSyncTimer=setInterval(async()=>{this.api.isLoggedIn()&&!this.syncEngine.isSyncing&&this.syncEngine.isDirty&&await this.syncEngine.sync(!0)},e)}}stopAutoSync(){this.autoSyncTimer!==null&&(clearInterval(this.autoSyncTimer),this.autoSyncTimer=null)}async changePassphrase(e){let s=this.crypto.generateSalt();this.settings.encryptionPassphrase=e,this.settings.encryptionSalt=s,this.crypto.clearCache(),this.settings.lastSyncTime=0,await this.saveSettings(),await this.api.pushEncryptionSalt(s,!0),await this.pushVaultKey(),await this.syncEngine.reEncryptLocal(),await this.syncNow()}async pushVaultKey(){let{encryptionPassphrase:e,password:s,username:n}=this.settings;if(!(!e||!s||!n))try{let i=await L(s,n),a=await O(e,i);await this.api.setVaultKey(a)}catch(i){console.warn("CloudSync: Could not push vault key:",i)}}async autoSelectVault(){try{let e=await this.api.listVaults();e.length>0&&!this.settings.vaultId&&(this.settings.vaultId=e[0].id,this.settings.vaultName=e[0].name,await this.saveSettings())}catch(e){console.warn("CloudSync: Could not fetch vault list:",e)}}async handleVaultKeyFromAuth(e){if(!e.encrypted_vault_key)return;let{password:s,username:n}=this.settings;if(!(!s||!n))try{let i=await L(s,n),a=await q(e.encrypted_vault_key,i);a!==this.settings.encryptionPassphrase&&(this.settings.encryptionPassphrase=a,await this.saveSettings(),new v.Notice("CloudSync: Encryption passphrase synced from account \u2014 encrypted files are now readable."))}catch(i){console.warn("CloudSync: Could not decrypt vault key:",i),new v.Notice("CloudSync: Could not load encryption key from account. Check your password is saved correctly in settings.")}}};
