var N=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var z=Object.getOwnPropertyNames;var j=Object.prototype.hasOwnProperty;var J=(u,t)=>{for(var e in t)N(u,e,{get:t[e],enumerable:!0})},Q=(u,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of z(t))!j.call(u,i)&&i!==e&&N(u,i,{get:()=>t[i],enumerable:!(s=G(t,i))||s.enumerable});return u};var X=u=>Q(N({},"__esModule",{value:!0}),u);var Y={};J(Y,{default:()=>_});module.exports=X(Y);var f=require("obsidian");var b=require("obsidian"),T=class{constructor(t){this.refreshing=null;this.plugin=t}get baseUrl(){return this.plugin.settings.serverUrl}get accessToken(){return this.plugin.settings.accessToken}async register(){let t=this.plugin.settings;if(!t.username||!t.password)throw new Error("Username and password are required");let s=await this.request("POST","/api/auth/register",{username:t.username,password:t.password,device_name:`Obsidian (${this.getDeviceName()})`},!1);return await this.storeAuth(s),s}async login(){let t=this.plugin.settings;if(!t.username||!t.password)throw new Error("Username and password are required");let s=await this.request("POST","/api/auth/login",{username:t.username,password:t.password,device_name:`Obsidian (${this.getDeviceName()})`,device_type:"obsidian"},!1);return await this.storeAuth(s),s}async logout(){this.plugin.settings.refreshToken&&await this.request("POST","/api/auth/logout",{refresh_token:this.plugin.settings.refreshToken},!1),this.plugin.settings.accessToken="",this.plugin.settings.refreshToken="",this.plugin.settings.userId="",this.plugin.settings.deviceId="",await this.plugin.saveSettings()}async refreshTokens(){if(!this.plugin.settings.refreshToken)throw new Error("No refresh token available. Please log in again.");let e=await this.request("POST","/api/auth/refresh",{refresh_token:this.plugin.settings.refreshToken},!1);await this.storeAuth(e)}async storeAuth(t){this.plugin.settings.accessToken=t.access_token,this.plugin.settings.refreshToken=t.refresh_token,this.plugin.settings.userId=t.user_id,this.plugin.settings.deviceId=t.device_id,t.encryption_salt&&this.plugin.settings.encryptionSalt!==t.encryption_salt&&(this.plugin.settings.encryptionSalt=t.encryption_salt,this.plugin.crypto.clearCache()),await this.plugin.saveSettings()}async delta(t,e=[]){return await this.authRequest("POST","/api/sync/delta",{files:t,deleted_paths:e})}async upload(t,e,s){return await this.authUpload("/api/sync/upload",t,e,s)}async download(t){return await this.authDownload(`/api/sync/download/${t}`)}async deleteFile(t){await this.authRequest("DELETE",`/api/sync/delete/${t}`)}async fixHash(t,e){await this.authRequest("POST","/api/sync/fix-hash",{file_id:t,hash:e})}async complete(){return await this.authRequest("POST","/api/sync/complete",{device_id:this.plugin.settings.deviceId})}async setVaultKey(t){await this.authRequest("PUT","/api/auth/vault-key",{encrypted_vault_key:t})}async pushEncryptionSalt(t,e=!1){await this.authRequest("PUT","/api/auth/encryption-salt",{salt:t,force:e})}async listFiles(t=!1){let e=t?"?include_deleted=true":"";return await this.authRequest("GET",`/api/files${e}`)}async fileVersions(t){return await this.authRequest("GET",`/api/files/${t}/versions`)}async rollback(t,e){return await this.authRequest("POST",`/api/files/${t}/rollback`,{version:e})}async listDevices(){return await this.authRequest("GET","/api/devices")}async revokeDevice(t){await this.authRequest("DELETE",`/api/devices/${t}`)}async authRequest(t,e,s){try{return await this.request(t,e,s,!0)}catch(i){if(i instanceof m&&i.status===401)return await this.handleTokenRefresh(),await this.request(t,e,s,!0);throw i}}async authUpload(t,e,s,i){try{return await this.uploadRequest(t,e,s,i)}catch(n){if(n instanceof m&&n.status===401)return await this.handleTokenRefresh(),await this.uploadRequest(t,e,s,i);throw n}}async authDownload(t){try{return await this.downloadRequest(t)}catch(e){if(e instanceof m&&e.status===401)return await this.handleTokenRefresh(),await this.downloadRequest(t);throw e}}async handleTokenRefresh(){this.refreshing||(this.refreshing=this.refreshTokens().finally(()=>{this.refreshing=null})),await this.refreshing}async request(t,e,s,i=!0){let n={"Content-Type":"application/json"};i&&this.accessToken&&(n.Authorization=`Bearer ${this.accessToken}`);let a={url:`${this.baseUrl}${e}`,method:t,headers:n,throw:!1};s!==void 0&&(a.body=JSON.stringify(s));let c=await(0,b.requestUrl)(a);if(c.status>=400){let o=`HTTP ${c.status}`;try{let r=c.json;r&&r.error?o=r.error:r&&r.message&&(o=r.message)}catch{}throw new m(o,c.status)}return c.status===204||!c.text?{}:c.json}arrayBufferToBase64(t){let e=new Uint8Array(t),s="",i=8192;for(let n=0;n<e.length;n+=i)s+=String.fromCharCode(...e.subarray(n,n+i));return btoa(s)}async uploadRequest(t,e,s,i){let n={path:e,data:this.arrayBufferToBase64(s)};i&&(n.hash=i);let a={"Content-Type":"application/json"};this.accessToken&&(a.Authorization=`Bearer ${this.accessToken}`);let c=await(0,b.requestUrl)({url:`${this.baseUrl}${t}`,method:"POST",headers:a,body:JSON.stringify(n),throw:!1});if(c.status>=400){let o=`HTTP ${c.status}`;try{let r=c.json;r&&r.error?o=r.error:r&&r.message&&(o=r.message)}catch{try{let r=c.text?.slice(0,120);r&&(o=r)}catch{}}throw new m(o,c.status)}return c.json}async downloadRequest(t){let e={};this.accessToken&&(e.Authorization=`Bearer ${this.accessToken}`);let s=await(0,b.requestUrl)({url:`${this.baseUrl}${t}`,method:"GET",headers:e,throw:!1});if(s.status>=400){let i=`HTTP ${s.status}`;try{let n=s.json;n&&n.error?i=n.error:n&&n.message&&(i=n.message)}catch{}throw new m(i,s.status)}return s.arrayBuffer}getDeviceName(){try{if(typeof navigator<"u"&&navigator.userAgent){if(navigator.userAgent.includes("Windows"))return"Windows";if(navigator.userAgent.includes("Mac"))return"macOS";if(navigator.userAgent.includes("Linux"))return"Linux";if(navigator.userAgent.includes("Android"))return"Android";if(navigator.userAgent.includes("iPhone")||navigator.userAgent.includes("iPad"))return"iOS"}}catch{}return"Desktop"}isLoggedIn(){return!!this.plugin.settings.accessToken}},m=class extends Error{constructor(t,e){super(t),this.name="ApiError",this.status=e}};var k=class{constructor(){this.cachedKey=null;this.cachedPassphrase="";this.cachedSaltHex=""}async deriveKey(t,e){let s=new TextEncoder,i=await crypto.subtle.importKey("raw",s.encode(t),"PBKDF2",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:e.buffer,iterations:1e5,hash:"SHA-256"},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async getKey(t,e){if(this.cachedKey&&this.cachedPassphrase===t&&this.cachedSaltHex===e)return this.cachedKey;let s=F(e);return this.cachedKey=await this.deriveKey(t,s),this.cachedPassphrase=t,this.cachedSaltHex=e,this.cachedKey}generateSalt(){let t=new Uint8Array(16);return crypto.getRandomValues(t),L(t)}async encrypt(t,e,s){let i=await this.getKey(e,s),n=new Uint8Array(12);crypto.getRandomValues(n);let a=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},i,t),c=new Uint8Array(12+a.byteLength);return c.set(n,0),c.set(new Uint8Array(a),12),c.buffer}async decrypt(t,e,s){let i=await this.getKey(e,s),n=new Uint8Array(t);if(n.byteLength<13)throw new Error("Encrypted data is too short");let a=n.slice(0,12),c=n.slice(12);try{return await crypto.subtle.decrypt({name:"AES-GCM",iv:a},i,c)}catch{throw new Error("Decryption failed. The passphrase may be incorrect or the data is corrupted.")}}clearCache(){this.cachedKey=null,this.cachedPassphrase="",this.cachedSaltHex=""}};function L(u){return Array.from(u).map(t=>t.toString(16).padStart(2,"0")).join("")}function F(u){let t=new Uint8Array(u.length/2);for(let e=0;e<u.length;e+=2)t[e/2]=parseInt(u.substring(e,e+2),16);return t}async function U(u,t){let e=new TextEncoder,s=await crypto.subtle.importKey("raw",e.encode(u),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e.encode(t),iterations:1e5,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function V(u,t){let e=new TextEncoder,s=new Uint8Array(12);crypto.getRandomValues(s);let i=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},t,e.encode(u)),n=new Uint8Array(12+i.byteLength);return n.set(s,0),n.set(new Uint8Array(i),12),L(n)}async function H(u,t){let e=F(u);if(e.length<13)throw new Error("Invalid vault key ciphertext");let s=e.slice(0,12),i=e.slice(12),n=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},t,i);return new TextDecoder().decode(n)}async function v(u){let t=await crypto.subtle.digest("SHA-256",u);return L(new Uint8Array(t))}var l=require("obsidian"),K=class extends l.AbstractInputSuggest{constructor(t,e,s,i){super(t,e),this.plugin=s,this.onSelect=i}getSuggestions(t){if(!t.trim())return[];let e=t.toLowerCase(),s=new Set(this.plugin.settings.excludePatterns),i=[];for(let n of this.plugin.app.vault.getAllLoadedFiles()){let a=n instanceof l.TFolder?n.path+"/":n.path;if(a.toLowerCase().includes(e)&&!s.has(a)&&(i.push(a),i.length>=20))break}return i}renderSuggestion(t,e){e.setText(t)}selectSuggestion(t,e){this.onSelect(t),this.setValue(""),this.close()}},q={serverUrl:"http://localhost:3000",username:"",password:"",autoSyncInterval:5,encryptionPassphrase:"",accessToken:"",refreshToken:"",userId:"",deviceId:"",encryptionSalt:"",lastSyncTime:0,excludePatterns:[],lastSyncedPaths:[]},x=class extends l.Modal{constructor(t,e){super(t),this.plugin=e}onOpen(){let{contentEl:t}=this;t.createEl("h2",{text:"Change Encryption Passphrase"}),t.createEl("p",{text:"Warning: this re-encrypts all files with the new passphrase. All other devices must update their passphrase before they can sync again.",attr:{style:"color: var(--text-muted); margin-bottom: 12px;"}});let e="",s="";new l.Setting(t).setName("New passphrase").addText(i=>{i.inputEl.type="password",i.setPlaceholder("Enter new passphrase\u2026"),i.onChange(n=>{e=n})}),new l.Setting(t).setName("Confirm passphrase").addText(i=>{i.inputEl.type="password",i.setPlaceholder("Confirm new passphrase\u2026"),i.onChange(n=>{s=n})}),new l.Setting(t).addButton(i=>i.setButtonText("Change Passphrase").setWarning().onClick(async()=>{if(!e){new l.Notice("CloudSync: Passphrase cannot be empty");return}if(e!==s){new l.Notice("CloudSync: Passphrases do not match");return}this.close();try{await this.plugin.changePassphrase(e),new l.Notice("CloudSync: Passphrase changed. Re-uploading all files\u2026")}catch(n){let a=n instanceof Error?n.message:String(n);new l.Notice(`CloudSync: Passphrase change failed \u2014 ${a}`)}})).addButton(i=>i.setButtonText("Cancel").onClick(()=>this.close()))}onClose(){this.contentEl.empty()}},A=class extends l.PluginSettingTab{constructor(t,e){super(t,e),this.plugin=e}display(){let{containerEl:t}=this;t.empty(),t.addClass("cloudsync-settings"),t.createEl("h2",{text:"CloudSync Settings"});let e=!!this.plugin.settings.accessToken;t.createDiv({cls:`connection-status ${e?"connected":"disconnected"}`}).setText(e?`Connected as ${this.plugin.settings.username} (Device: ${this.plugin.settings.deviceId.substring(0,8)}...)`:"Not connected"),t.createEl("h3",{text:"Server"}),new l.Setting(t).setName("Server URL").setDesc("The URL of your ObsidianCloudSync server").addText(o=>o.setPlaceholder("http://localhost:3000").setValue(this.plugin.settings.serverUrl).onChange(async r=>{this.plugin.settings.serverUrl=r.replace(/\/+$/,""),await this.plugin.saveSettings()})),t.createEl("h3",{text:"Authentication"}),new l.Setting(t).setName("Username").addText(o=>o.setPlaceholder("username").setValue(this.plugin.settings.username).onChange(async r=>{this.plugin.settings.username=r,await this.plugin.saveSettings()})),new l.Setting(t).setName("Password").addText(o=>{o.inputEl.type="password",o.setPlaceholder("password").setValue(this.plugin.settings.password).onChange(async r=>{this.plugin.settings.password=r,await this.plugin.saveSettings()})}),new l.Setting(t).setName("Account").addButton(o=>o.setButtonText("Login").onClick(async()=>{try{let r=await this.plugin.api.login();await this.plugin.handleVaultKeyFromAuth(r),new l.Notice("CloudSync: Logged in successfully"),this.display()}catch(r){let p=r instanceof Error?r.message:String(r);new l.Notice(`CloudSync: Login failed \u2014 ${p}`)}})).addButton(o=>o.setButtonText("Register").onClick(async()=>{try{await this.plugin.api.register(),new l.Notice("CloudSync: Registered and logged in"),this.display()}catch(r){let p=r instanceof Error?r.message:String(r);new l.Notice(`CloudSync: Registration failed \u2014 ${p}`)}})),e&&new l.Setting(t).setName("Session").setDesc("Clears stored tokens from this device").addButton(o=>o.setButtonText("Logout").setWarning().onClick(async()=>{try{await this.plugin.api.logout()}catch{}this.plugin.settings.accessToken="",this.plugin.settings.refreshToken="",this.plugin.settings.userId="",this.plugin.settings.deviceId="",await this.plugin.saveSettings(),this.plugin.wsClient?.disconnect(),new l.Notice("CloudSync: Logged out"),this.display()})),t.createEl("h3",{text:"Encryption"});let i=!!this.plugin.settings.encryptionSalt,n=!!this.plugin.settings.encryptionPassphrase;if(i&&n)new l.Setting(t).setName("Encryption").setDesc("Active \u2014 files are encrypted with AES-256-GCM before leaving this device. All synced devices use the same key.").addButton(o=>o.setButtonText("Change Passphrase").setWarning().onClick(()=>{new x(this.plugin.app,this.plugin).open()}));else if(i&&!n)new l.Setting(t).setName("Encryption \u2014 passphrase missing").setDesc("This account has encryption enabled but no passphrase is set on this device. Files will download as garbled data until the passphrase is loaded. Click 'Load from account' to fetch it automatically using your login password.").addButton(o=>o.setButtonText("Load from account").setCta().onClick(async()=>{try{let r=await this.plugin.api.login();await this.plugin.handleVaultKeyFromAuth(r),this.display()}catch(r){let p=r instanceof Error?r.message:String(r);new l.Notice(`CloudSync: Could not load encryption key \u2014 ${p}`)}})).addButton(o=>o.setButtonText("Enter manually").onClick(()=>{new x(this.plugin.app,this.plugin).open()}));else{let o=n?" Passphrase is set and will activate on the next sync.":"";new l.Setting(t).setName("Encryption passphrase").setDesc("Encrypt all files client-side before uploading. Leave empty to sync without encryption. All devices must use the same passphrase."+o).addText(r=>{r.inputEl.type="password",r.setPlaceholder("Enter a passphrase\u2026").setValue(this.plugin.settings.encryptionPassphrase).onChange(async p=>{this.plugin.settings.encryptionPassphrase=p,await this.plugin.saveSettings(),this.plugin.pushVaultKey()})})}t.createEl("h3",{text:"Sync"}),new l.Setting(t).setName("Auto-sync").setDesc("When to automatically sync changes to the server.").addDropdown(o=>o.addOption("0","Disabled").addOption("-1","Only on change").addOption("5","Every 5 minutes").addOption("10","Every 10 minutes").addOption("15","Every 15 minutes").addOption("30","Every 30 minutes").addOption("60","Every hour").setValue(String(this.plugin.settings.autoSyncInterval)).onChange(async r=>{this.plugin.settings.autoSyncInterval=parseInt(r,10),await this.plugin.saveSettings(),this.plugin.restartAutoSync()})),this.plugin.settings.lastSyncTime>0?new l.Setting(t).setName("Last sync").setDesc(new Date(this.plugin.settings.lastSyncTime).toLocaleString()).addButton(o=>o.setButtonText("Sync now").onClick(async()=>{await this.plugin.syncNow()})):new l.Setting(t).setName("Manual sync").addButton(o=>o.setButtonText("Sync now").onClick(async()=>{await this.plugin.syncNow()})),new l.Setting(t).setName("Directional sync").setDesc("Push: upload local files to server \u2014 local wins on conflicts, server changes are ignored. Pull: download server files to local \u2014 server wins on conflicts, local uploads are skipped. Use Push when you paste files locally that have older timestamps and don't want them overwritten.").addButton(o=>o.setButtonText("Push only").onClick(async()=>{await this.plugin.pushNow()})).addButton(o=>o.setButtonText("Pull only").onClick(async()=>{await this.plugin.pullNow()})),t.createEl("h3",{text:"Exclude from sync"});let a=t.createDiv({cls:"cloudsync-chip-list"});this.renderChips(a);let c;new l.Setting(t).setName("Add exclusion").setDesc("Search vault files and folders, or type a glob pattern (e.g. *.tmp) and press Enter.").addText(o=>{o.setPlaceholder("Search files and folders\u2026"),c=o,new K(this.app,o.inputEl,this.plugin,async r=>{await this.addPattern(r,a)}),o.inputEl.addEventListener("keydown",async r=>{if(r.key==="Enter"){let p=o.getValue().trim();p&&(await this.addPattern(p,a),o.setValue(""))}})})}async addPattern(t,e){this.plugin.settings.excludePatterns.includes(t)||(this.plugin.settings.excludePatterns.push(t),await this.plugin.saveSettings(),this.renderChips(e))}renderChips(t){if(t.empty(),this.plugin.settings.excludePatterns.length===0){t.createEl("div",{text:"No exclusions added.",cls:"cloudsync-chip-empty"});return}for(let e of[...this.plugin.settings.excludePatterns]){let s=t.createDiv({cls:"cloudsync-chip"});s.createEl("span",{text:e,cls:"cloudsync-chip-text"});let i=s.createEl("button",{cls:"cloudsync-chip-remove",text:"\xD7"});i.setAttribute("aria-label",`Remove ${e}`),i.addEventListener("click",async()=>{this.plugin.settings.excludePatterns=this.plugin.settings.excludePatterns.filter(n=>n!==e),await this.plugin.saveSettings(),this.renderChips(t)})}}};var B=class{constructor(t,e){this.state="idle";this.message="";this.progress="";this.ticker=null;this.plugin=t,this.statusBarEl=e,this.ticker=setInterval(()=>{this.state==="idle"&&this.render()},3e4),this.render()}destroy(){this.ticker!==null&&(clearInterval(this.ticker),this.ticker=null)}setState(t,e){this.state=t,this.message=e||"",this.progress="",this.render()}setProgress(t,e,s){this.state="syncing",this.progress=`${t}/${e}`,this.message=s||"",this.render()}render(){this.statusBarEl.empty(),this.statusBarEl.addClass("cloudsync-status-bar"),this.statusBarEl.createSpan({cls:`sync-icon ${this.state}`}).setAttribute("aria-label",this.state);let e;switch(this.state){case"idle":this.plugin.settings.lastSyncTime>0?e=`Synced ${this.timeAgo(this.plugin.settings.lastSyncTime)}`:e="CloudSync: Ready";break;case"syncing":this.progress?e=`Syncing ${this.progress} files...`:e=this.message||"Syncing...";break;case"error":e=this.message||"Sync error";break}this.statusBarEl.createSpan({text:e})}timeAgo(t){let s=Date.now()-t,i=Math.floor(s/1e3);if(i<60)return"just now";let n=Math.floor(i/60);if(n<60)return`${n}m ago`;let a=Math.floor(n/60);return a<24?`${a}h ago`:`${Math.floor(a/24)}d ago`}};var g=require("obsidian");var $=class{constructor(t){this.syncing=!1;this.hashCache=new Map;this.dirty=!1;this.plugin=t}get isSyncing(){return this.syncing}get isDirty(){return this.dirty}markDirty(){this.dirty=!0}async sync(t=!1,e="bidirectional"){if(this.syncing){t||new g.Notice("CloudSync: Sync already in progress");return}if(!this.plugin.api.isLoggedIn()){t||new g.Notice("CloudSync: Not logged in. Please log in first.");return}this.syncing=!0,this.plugin.statusBar.setState("syncing","Building manifest...");try{let s=await this.buildManifest();this.plugin.statusBar.setState("syncing",`Checking ${s.length} files...`);let i=new Set(s.map(h=>h.path)),n=this.plugin.settings.lastSyncedPaths??[],a=[];if(n.length>0){let h=n.filter(P=>!i.has(P)),d=h.length/n.length;d<=.5?a.push(...h):console.warn(`CloudSync: ${h.length}/${n.length} tracked files appear deleted \u2014 ratio ${(d*100).toFixed(0)}% exceeds 50% threshold, skipping explicit deletes (treating as possible vault wipe; server will send Download instructions instead)`)}let c=e==="pull"?[]:a,o=await this.plugin.api.delta(s,c);await this.reconcileEncryptionSalt(o.encryption_salt);let r=e==="push"?o.instructions.filter(h=>h.action==="upload"||h.action==="conflict"):e==="pull"?o.instructions.filter(h=>h.action==="download"||h.action==="delete"||h.action==="conflict"):o.instructions;if(r.length===0){await this.plugin.api.complete(),this.plugin.settings.lastSyncTime=Date.now(),this.plugin.settings.lastSyncedPaths=s.map(h=>h.path),await this.plugin.saveSettings(),this.dirty=!1,this.plugin.statusBar.setState("idle");return}let p=0,y=0,E=0,S=0,I=0,D=0,C=r.length;for(let h=0;h<r.length;h++){let d=r[h];try{switch(d.action){case"upload":this.plugin.statusBar.setProgress(h+1,C,`Uploading: ${d.path}`),await this.withRetry(()=>this.handleUpload(d),d.path),p++;break;case"download":this.plugin.statusBar.setProgress(h+1,C,`Downloading: ${d.path}`),await this.handleDownload(d)&&y++;break;case"conflict":this.plugin.statusBar.setProgress(h+1,C,`Resolving conflict: ${d.path}`),e==="push"?(await this.withRetry(()=>this.handleUpload(d),d.path),p++):e==="pull"?await this.handleDownload(d)&&y++:(await this.handleConflict(d),S++);break;case"delete":this.plugin.statusBar.setProgress(h+1,C,`Deleting: ${d.path}`),await this.handleDelete(d),E++;break}}catch(P){I++,(d.action==="download"||d.action==="conflict")&&D++;let O=P instanceof Error?P.message:String(P),M=P.status,W=M?`[HTTP ${M}] `:"";console.error(`CloudSync: Error processing ${d.path}: ${W}${O}`)}}D===0?(await this.plugin.api.complete(),this.plugin.settings.lastSyncTime=Date.now(),this.plugin.settings.lastSyncedPaths=s.map(h=>h.path),await this.plugin.saveSettings(),this.dirty=!1):console.warn(`CloudSync: ${D} download(s) failed \u2014 skipping complete() so the sync cursor is not advanced. Will retry on next sync.`);let w=[];if(p>0&&w.push(`${p} uploaded`),y>0&&w.push(`${y} downloaded`),E>0&&w.push(`${E} deleted`),S>0&&w.push(`${S} conflicts`),I>0&&w.push(`${I} errors`),!t||w.length>0){let h=w.length>0?w.join(", "):"no changes",d=e==="push"?"Push":e==="pull"?"Pull":"Sync";new g.Notice(`CloudSync: ${d} complete (${h})`)}this.plugin.statusBar.setState("idle")}catch(s){let i=s instanceof Error?s.message:String(s);console.error("CloudSync: Sync failed:",i),new g.Notice(`CloudSync: Sync failed - ${i}`),this.plugin.statusBar.setState("error",`Error: ${i}`)}finally{this.syncing=!1}}async buildManifest(){let t=this.plugin.app.vault,e=t.getFiles(),s=[],i=new Set,n=0;for(let a of e){if(this.shouldSkip(a.path))continue;i.add(a.path);let c=Math.floor(a.stat.mtime/1e3),o=a.stat.size,r=this.hashCache.get(a.path);if(r&&r.mtime===c&&r.size===o){s.push({path:a.path,hash:r.hash,size:r.size,modified_at:c}),n++;continue}try{let p=await t.readBinary(a),y=await v(p);this.hashCache.set(a.path,{hash:y,mtime:c,size:p.byteLength}),s.push({path:a.path,hash:y,size:p.byteLength,modified_at:c})}catch(p){let y=p instanceof Error?p.message:String(p);console.warn(`CloudSync: Could not read ${a.path}: ${y}`)}}for(let a of this.hashCache.keys())i.has(a)||this.hashCache.delete(a);return console.log(`CloudSync: Manifest built \u2014 ${s.length} files, ${n} cached, ${s.length-n} hashed`),s}async handleUpload(t){let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);if(!(s instanceof g.TFile))throw new Error(`File not found in vault: ${t.path}`);let i=await e.readBinary(s),n=await v(i),a;this.isEncryptionEnabled()?a=await this.plugin.crypto.encrypt(i,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt):a=i,await this.plugin.api.upload(t.path,a,n)}async handleDownload(t){if(!t.file_id)throw new Error(`No file_id for download: ${t.path}`);if(this.plugin.settings.encryptionSalt&&!this.plugin.settings.encryptionPassphrase)throw new Error(`Cannot download "${t.path}" \u2014 server has encryption configured but no passphrase is set on this device. Enter your encryption passphrase in plugin settings.`);let e=await this.plugin.api.download(t.file_id),s;if(this.isEncryptionEnabled())try{s=await this.plugin.crypto.decrypt(e,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt)}catch(c){let o=await v(e),r=this.plugin.app.vault,p=(0,g.normalizePath)(t.path),y=r.getAbstractFileByPath(p);if(y instanceof g.TFile){let E=await r.readBinary(y),S=await v(E);if(S===o)return console.warn(`CloudSync: Decryption skipped for "${t.path}" \u2014 blob matches local content (uploaded before encryption was enabled). Fixing server hash.`),await this.plugin.api.fixHash(t.file_id,S),!1}if(t.server_hash&&o===t.server_hash)console.warn(`CloudSync: Using plaintext blob for "${t.path}" \u2014 file was uploaded before encryption was enabled.`),s=e;else throw c}else s=e;let i=this.plugin.app.vault,n=(0,g.normalizePath)(t.path),a=i.getAbstractFileByPath(n);if(a instanceof g.TFile){let c;try{c=await i.readBinary(a)}catch{return console.warn(`CloudSync: Could not read "${t.path}" for comparison (file may be locked) \u2014 skipping`),!1}let o=await v(c),r=await v(s);return o===r?(await this.plugin.api.fixHash(t.file_id,o),!1):(await i.modifyBinary(a,s),!0)}return await this.ensureDirectory(n),await i.createBinary(n,s),!0}async handleConflict(t){if(t.file_id){let i=await this.plugin.api.download(t.file_id);this.isEncryptionEnabled()&&(i=await this.plugin.crypto.decrypt(i,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt));let n=this.makeConflictPath(t.path);await this.ensureDirectory(n);let a=this.plugin.app.vault,c=a.getAbstractFileByPath(n);c instanceof g.TFile?await a.modifyBinary(c,i):await a.createBinary(n,i),new g.Notice(`CloudSync: Conflict on "${t.path}" - server version saved as "${n}"`)}let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);if(s instanceof g.TFile){let i=await e.readBinary(s),n=await v(i),a=i;this.isEncryptionEnabled()&&(a=await this.plugin.crypto.encrypt(i,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt)),await this.plugin.api.upload(t.path,a,n)}}async handleDelete(t){let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);s instanceof g.TFile&&await e.delete(s)}makeConflictPath(t){let e=new Date().toISOString().replace(/[:.]/g,"-").slice(0,19),s=t.lastIndexOf(".");if(s===-1)return`${t}.conflict-${e}`;let i=t.substring(0,s),n=t.substring(s);return`${i}.conflict-${e}${n}`}async ensureDirectory(t){let e=t.split("/");if(e.length<=1)return;let s=e.slice(0,-1).join("/"),i=this.plugin.app.vault;i.getAbstractFileByPath(s)||await i.createFolder(s)}shouldSkip(t){if(t.startsWith(".")||t==="data.json")return!0;for(let e of this.plugin.settings.excludePatterns)if(this.matchesPattern(t,e))return!0;return!1}matchesPattern(t,e){if(e.endsWith("/"))return t.startsWith(e)||t.startsWith(e.slice(0,-1));if(t===e)return!0;let s="^";for(let i=0;i<e.length;i++){let n=e[i];n==="*"&&e[i+1]==="*"?(s+=".*",i++,e[i+1]==="/"&&i++):n==="*"?s+="[^/]*":n==="?"||n==="."||n==="("||n===")"||n==="["||n==="]"||n==="{"||n==="}"||n==="+"||n==="^"||n==="$"||n==="|"||n==="\\"?s+="\\"+n:s+=n}s+="$";try{return new RegExp(s).test(t)}catch{return!1}}async withRetry(t,e,s=3){let i;for(let n=1;n<=s;n++)try{return await t()}catch(a){i=a;let c=a.status;if(c===401||c===403||c===404||c===413)throw a;if(n<s){let o=n*2e3;console.warn(`CloudSync: Upload attempt ${n} failed for ${e} \u2014 retrying in ${o/1e3}s`),await new Promise(r=>setTimeout(r,o))}}throw i}async reEncryptLocal(){if(this.syncing)throw new Error("Sync already in progress");if(!this.plugin.api.isLoggedIn())throw new Error("Not logged in");this.syncing=!0,this.plugin.statusBar.setState("syncing","Re-encrypting files...");try{let t=await this.buildManifest(),e=0,s=0,i=t.length;for(let n=0;n<t.length;n++){let a=t[n];this.plugin.statusBar.setProgress(n+1,i,`Re-encrypting: ${a.path}`);let c={path:a.path,action:"upload",file_id:null,server_hash:null,server_modified_at:null};try{await this.withRetry(()=>this.handleUpload(c),a.path),e++}catch(o){s++;let r=o instanceof Error?o.message:String(o);console.error(`CloudSync: Re-encrypt failed for ${a.path}: ${r}`)}}console.log(`CloudSync: Re-encrypted ${e} local file(s)${s>0?`, ${s} error(s)`:""}`)}finally{this.syncing=!1,this.plugin.statusBar.setState("idle")}}async reconcileEncryptionSalt(t){if(t)this.plugin.settings.encryptionSalt!==t&&(this.plugin.settings.encryptionSalt=t,this.plugin.crypto.clearCache(),await this.plugin.saveSettings()),this.plugin.settings.encryptionPassphrase&&this.plugin.pushVaultKey();else if(this.plugin.settings.encryptionPassphrase){this.plugin.settings.encryptionSalt||(this.plugin.settings.encryptionSalt=this.plugin.crypto.generateSalt(),await this.plugin.saveSettings());try{await this.plugin.api.pushEncryptionSalt(this.plugin.settings.encryptionSalt),this.plugin.pushVaultKey()}catch{}}}isEncryptionEnabled(){return!!this.plugin.settings.encryptionPassphrase&&!!this.plugin.settings.encryptionSalt}};var R=class{constructor(t){this.ws=null;this.reconnectTimer=null;this.reconnectDelay=1e3;this.maxReconnectDelay=3e4;this.alive=!1;this.plugin=t}connect(){if(!this.plugin.api.isLoggedIn())return;let t=this.plugin.settings.serverUrl,e=this.plugin.settings.accessToken,i=`${t.replace(/^https:\/\//,"wss://").replace(/^http:\/\//,"ws://")}/api/ws?token=${encodeURIComponent(e)}`;try{this.ws=new WebSocket(i),this.alive=!0,this.ws.onopen=()=>{console.log("CloudSync WS: Connected"),this.reconnectDelay=1e3},this.ws.onmessage=n=>{this.handleMessage(n.data)},this.ws.onclose=n=>{console.log(`CloudSync WS: Closed (code=${n.code}, reason=${n.reason})`),this.ws=null,this.alive&&this.scheduleReconnect()},this.ws.onerror=()=>{console.warn("CloudSync WS: Connection error")}}catch(n){console.warn("CloudSync WS: Failed to connect:",n),this.scheduleReconnect()}}disconnect(){this.alive=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.ws&&(this.ws.close(),this.ws=null)}handleMessage(t){try{let e=JSON.parse(t);e.type==="sync_update"&&(console.log(`CloudSync WS: Sync update - ${e.action} ${e.file_path}`),this.plugin.syncEngine.isSyncing||setTimeout(()=>{this.plugin.syncEngine.isSyncing||this.plugin.syncNow()},2e3))}catch{}}scheduleReconnect(){this.alive&&(console.log(`CloudSync WS: Reconnecting in ${this.reconnectDelay/1e3}s...`),this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=null,this.connect()},this.reconnectDelay),this.reconnectDelay=Math.min(this.reconnectDelay*2,this.maxReconnectDelay))}get isConnected(){return this.ws!==null&&this.ws.readyState===WebSocket.OPEN}};var _=class extends f.Plugin{constructor(e,s){super(e,s);this.autoSyncTimer=null;this.debouncedSync=(0,f.debounce)(()=>{this.api.isLoggedIn()&&!this.syncEngine.isSyncing&&this.syncEngine.sync(!0)},3e3,!0)}async onload(){console.log("CloudSync: Loading plugin"),await this.loadSettings(),this.api=new T(this),this.crypto=new k,this.syncEngine=new $(this),this.wsClient=new R(this);let e=this.addStatusBarItem();this.statusBar=new B(this,e),this.addSettingTab(new A(this.app,this)),this.addRibbonIcon("refresh-cw","CloudSync: Sync now",async()=>{await this.syncNow()}),this.addCommand({id:"cloudsync-sync-now",name:"Sync now (bidirectional)",callback:async()=>{await this.syncNow()}}),this.addCommand({id:"cloudsync-push-now",name:"Push now (upload local changes to server)",callback:async()=>{await this.pushNow()}}),this.addCommand({id:"cloudsync-pull-now",name:"Pull now (download server changes to local)",callback:async()=>{await this.pullNow()}}),this.addCommand({id:"cloudsync-view-status",name:"View sync status",callback:()=>{this.showSyncStatus()}});let s=i=>{i instanceof f.TFile&&!i.path.startsWith(".obsidian/")&&!this.syncEngine.isSyncing&&(this.syncEngine.markDirty(),this.settings.autoSyncInterval!==0&&this.debouncedSync())};this.registerEvent(this.app.vault.on("modify",s)),this.registerEvent(this.app.vault.on("create",s)),this.registerEvent(this.app.vault.on("delete",s)),this.registerEvent(this.app.vault.on("rename",s)),this.restartAutoSync(),this.api.isLoggedIn()&&(setTimeout(()=>{this.syncNow()},5e3),this.wsClient.connect())}async onunload(){console.log("CloudSync: Unloading plugin"),this.stopAutoSync(),this.statusBar.destroy(),this.wsClient.disconnect()}async loadSettings(){this.settings=Object.assign({},q,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}async syncNow(){await this.syncEngine.sync()}async pushNow(){await this.syncEngine.sync(!1,"push")}async pullNow(){await this.syncEngine.sync(!1,"pull")}showSyncStatus(){let e=this.settings,s=[];this.api.isLoggedIn()?(s.push(`Logged in as: ${e.username}`),s.push(`Device ID: ${e.deviceId.substring(0,8)}...`)):s.push("Not logged in"),e.lastSyncTime>0?s.push(`Last sync: ${new Date(e.lastSyncTime).toLocaleString()}`):s.push("Never synced");let i=e.autoSyncInterval===-1?"only on change":e.autoSyncInterval===0?"disabled":`every ${e.autoSyncInterval} min`;s.push(`Auto-sync: ${i}`),s.push(`Encryption: ${e.encryptionPassphrase?"enabled":"disabled"}`),this.syncEngine.isSyncing?s.push("Status: Syncing..."):s.push("Status: Idle"),new f.Notice(s.join(`
`),1e4)}restartAutoSync(){if(this.stopAutoSync(),this.settings.autoSyncInterval>0){let e=this.settings.autoSyncInterval*60*1e3;this.autoSyncTimer=setInterval(async()=>{this.api.isLoggedIn()&&!this.syncEngine.isSyncing&&this.syncEngine.isDirty&&await this.syncEngine.sync(!0)},e)}}stopAutoSync(){this.autoSyncTimer!==null&&(clearInterval(this.autoSyncTimer),this.autoSyncTimer=null)}async changePassphrase(e){let s=this.crypto.generateSalt();this.settings.encryptionPassphrase=e,this.settings.encryptionSalt=s,this.crypto.clearCache(),this.settings.lastSyncTime=0,await this.saveSettings(),await this.api.pushEncryptionSalt(s,!0),await this.pushVaultKey(),await this.syncEngine.reEncryptLocal(),await this.syncNow()}async pushVaultKey(){let{encryptionPassphrase:e,password:s,username:i}=this.settings;if(!(!e||!s||!i))try{let n=await U(s,i),a=await V(e,n);await this.api.setVaultKey(a)}catch(n){console.warn("CloudSync: Could not push vault key:",n)}}async handleVaultKeyFromAuth(e){if(!e.encrypted_vault_key)return;let{password:s,username:i}=this.settings;if(!(!s||!i))try{let n=await U(s,i),a=await H(e.encrypted_vault_key,n);a!==this.settings.encryptionPassphrase&&(this.settings.encryptionPassphrase=a,await this.saveSettings(),new f.Notice("CloudSync: Encryption passphrase synced from account \u2014 encrypted files are now readable."))}catch(n){console.warn("CloudSync: Could not decrypt vault key:",n),new f.Notice("CloudSync: Could not load encryption key from account. Check your password is saved correctly in settings.")}}};
