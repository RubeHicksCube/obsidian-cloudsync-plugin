var I=Object.defineProperty;var G=Object.getOwnPropertyDescriptor;var z=Object.getOwnPropertyNames;var j=Object.prototype.hasOwnProperty;var J=(u,t)=>{for(var e in t)I(u,e,{get:t[e],enumerable:!0})},Q=(u,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of z(t))!j.call(u,i)&&i!==e&&I(u,i,{get:()=>t[i],enumerable:!(s=G(t,i))||s.enumerable});return u};var X=u=>Q(I({},"__esModule",{value:!0}),u);var Y={};J(Y,{default:()=>R});module.exports=X(Y);var f=require("obsidian");var T=require("obsidian"),C=class{constructor(t){this.refreshing=null;this.plugin=t}get baseUrl(){return this.plugin.settings.serverUrl}get accessToken(){return this.plugin.settings.accessToken}async register(){let t=this.plugin.settings;if(!t.username||!t.password)throw new Error("Username and password are required");let s=await this.request("POST","/api/auth/register",{username:t.username,password:t.password,device_name:`Obsidian (${this.getDeviceName()})`},!1);return await this.storeAuth(s),s}async login(){let t=this.plugin.settings;if(!t.username||!t.password)throw new Error("Username and password are required");let s=await this.request("POST","/api/auth/login",{username:t.username,password:t.password,device_name:`Obsidian (${this.getDeviceName()})`,device_type:"obsidian"},!1);return await this.storeAuth(s),s}async logout(){this.plugin.settings.refreshToken&&await this.request("POST","/api/auth/logout",{refresh_token:this.plugin.settings.refreshToken},!1),this.plugin.settings.accessToken="",this.plugin.settings.refreshToken="",this.plugin.settings.userId="",this.plugin.settings.deviceId="",await this.plugin.saveSettings()}async refreshTokens(){if(!this.plugin.settings.refreshToken)throw new Error("No refresh token available. Please log in again.");let e=await this.request("POST","/api/auth/refresh",{refresh_token:this.plugin.settings.refreshToken},!1);await this.storeAuth(e)}async storeAuth(t){this.plugin.settings.accessToken=t.access_token,this.plugin.settings.refreshToken=t.refresh_token,this.plugin.settings.userId=t.user_id,this.plugin.settings.deviceId=t.device_id,t.encryption_salt&&this.plugin.settings.encryptionSalt!==t.encryption_salt&&(this.plugin.settings.encryptionSalt=t.encryption_salt,this.plugin.crypto.clearCache()),await this.plugin.saveSettings()}async delta(t,e=[]){return await this.authRequest("POST","/api/sync/delta",{files:t,deleted_paths:e})}async upload(t,e,s){return await this.authUpload("/api/sync/upload",t,e,s)}async download(t){return await this.authDownload(`/api/sync/download/${t}`)}async deleteFile(t){await this.authRequest("DELETE",`/api/sync/delete/${t}`)}async fixHash(t,e){await this.authRequest("POST","/api/sync/fix-hash",{file_id:t,hash:e})}async complete(){return await this.authRequest("POST","/api/sync/complete",{device_id:this.plugin.settings.deviceId})}async setVaultKey(t){await this.authRequest("PUT","/api/auth/vault-key",{encrypted_vault_key:t})}async pushEncryptionSalt(t,e=!1){await this.authRequest("PUT","/api/auth/encryption-salt",{salt:t,force:e})}async listFiles(t=!1){let e=t?"?include_deleted=true":"";return await this.authRequest("GET",`/api/files${e}`)}async fileVersions(t){return await this.authRequest("GET",`/api/files/${t}/versions`)}async rollback(t,e){return await this.authRequest("POST",`/api/files/${t}/rollback`,{version:e})}async listDevices(){return await this.authRequest("GET","/api/devices")}async revokeDevice(t){await this.authRequest("DELETE",`/api/devices/${t}`)}async authRequest(t,e,s){try{return await this.request(t,e,s,!0)}catch(i){if(i instanceof m&&i.status===401)return await this.handleTokenRefresh(),await this.request(t,e,s,!0);throw i}}async authUpload(t,e,s,i){try{return await this.uploadRequest(t,e,s,i)}catch(n){if(n instanceof m&&n.status===401)return await this.handleTokenRefresh(),await this.uploadRequest(t,e,s,i);throw n}}async authDownload(t){try{return await this.downloadRequest(t)}catch(e){if(e instanceof m&&e.status===401)return await this.handleTokenRefresh(),await this.downloadRequest(t);throw e}}async handleTokenRefresh(){this.refreshing||(this.refreshing=this.refreshTokens().finally(()=>{this.refreshing=null})),await this.refreshing}async request(t,e,s,i=!0){let n={"Content-Type":"application/json"};i&&this.accessToken&&(n.Authorization=`Bearer ${this.accessToken}`);let r={url:`${this.baseUrl}${e}`,method:t,headers:n,throw:!1};s!==void 0&&(r.body=JSON.stringify(s));let a=await(0,T.requestUrl)(r);if(a.status>=400){let o=`HTTP ${a.status}`;try{let c=a.json;c&&c.error?o=c.error:c&&c.message&&(o=c.message)}catch{}throw new m(o,a.status)}return a.status===204||!a.text?{}:a.json}arrayBufferToBase64(t){let e=new Uint8Array(t),s="",i=8192;for(let n=0;n<e.length;n+=i)s+=String.fromCharCode(...e.subarray(n,n+i));return btoa(s)}async uploadRequest(t,e,s,i){let n={path:e,data:this.arrayBufferToBase64(s)};i&&(n.hash=i);let r={"Content-Type":"application/json"};this.accessToken&&(r.Authorization=`Bearer ${this.accessToken}`);let a=await(0,T.requestUrl)({url:`${this.baseUrl}${t}`,method:"POST",headers:r,body:JSON.stringify(n),throw:!1});if(a.status>=400){let o=`HTTP ${a.status}`;try{let c=a.json;c&&c.error?o=c.error:c&&c.message&&(o=c.message)}catch{try{let c=a.text?.slice(0,120);c&&(o=c)}catch{}}throw new m(o,a.status)}return a.json}async downloadRequest(t){let e={};this.accessToken&&(e.Authorization=`Bearer ${this.accessToken}`);let s=await(0,T.requestUrl)({url:`${this.baseUrl}${t}`,method:"GET",headers:e,throw:!1});if(s.status>=400){let i=`HTTP ${s.status}`;try{let n=s.json;n&&n.error?i=n.error:n&&n.message&&(i=n.message)}catch{}throw new m(i,s.status)}return s.arrayBuffer}getDeviceName(){try{if(typeof navigator<"u"&&navigator.userAgent){if(navigator.userAgent.includes("Windows"))return"Windows";if(navigator.userAgent.includes("Mac"))return"macOS";if(navigator.userAgent.includes("Linux"))return"Linux";if(navigator.userAgent.includes("Android"))return"Android";if(navigator.userAgent.includes("iPhone")||navigator.userAgent.includes("iPad"))return"iOS"}}catch{}return"Desktop"}isLoggedIn(){return!!this.plugin.settings.accessToken}},m=class extends Error{constructor(t,e){super(t),this.name="ApiError",this.status=e}};var k=class{constructor(){this.cachedKey=null;this.cachedPassphrase="";this.cachedSaltHex=""}async deriveKey(t,e){let s=new TextEncoder,i=await crypto.subtle.importKey("raw",s.encode(t),"PBKDF2",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:e.buffer,iterations:1e5,hash:"SHA-256"},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async getKey(t,e){if(this.cachedKey&&this.cachedPassphrase===t&&this.cachedSaltHex===e)return this.cachedKey;let s=F(e);return this.cachedKey=await this.deriveKey(t,s),this.cachedPassphrase=t,this.cachedSaltHex=e,this.cachedKey}generateSalt(){let t=new Uint8Array(16);return crypto.getRandomValues(t),N(t)}async encrypt(t,e,s){let i=await this.getKey(e,s),n=new Uint8Array(12);crypto.getRandomValues(n);let r=await crypto.subtle.encrypt({name:"AES-GCM",iv:n},i,t),a=new Uint8Array(12+r.byteLength);return a.set(n,0),a.set(new Uint8Array(r),12),a.buffer}async decrypt(t,e,s){let i=await this.getKey(e,s),n=new Uint8Array(t);if(n.byteLength<13)throw new Error("Encrypted data is too short");let r=n.slice(0,12),a=n.slice(12);try{return await crypto.subtle.decrypt({name:"AES-GCM",iv:r},i,a)}catch{throw new Error("Decryption failed. The passphrase may be incorrect or the data is corrupted.")}}clearCache(){this.cachedKey=null,this.cachedPassphrase="",this.cachedSaltHex=""}};function N(u){return Array.from(u).map(t=>t.toString(16).padStart(2,"0")).join("")}function F(u){let t=new Uint8Array(u.length/2);for(let e=0;e<u.length;e+=2)t[e/2]=parseInt(u.substring(e,e+2),16);return t}async function U(u,t){let e=new TextEncoder,s=await crypto.subtle.importKey("raw",e.encode(u),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:e.encode(t),iterations:1e5,hash:"SHA-256"},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function V(u,t){let e=new TextEncoder,s=new Uint8Array(12);crypto.getRandomValues(s);let i=await crypto.subtle.encrypt({name:"AES-GCM",iv:s},t,e.encode(u)),n=new Uint8Array(12+i.byteLength);return n.set(s,0),n.set(new Uint8Array(i),12),N(n)}async function H(u,t){let e=F(u);if(e.length<13)throw new Error("Invalid vault key ciphertext");let s=e.slice(0,12),i=e.slice(12),n=await crypto.subtle.decrypt({name:"AES-GCM",iv:s},t,i);return new TextDecoder().decode(n)}async function v(u){let t=await crypto.subtle.digest("SHA-256",u);return N(new Uint8Array(t))}var l=require("obsidian"),L=class extends l.AbstractInputSuggest{constructor(t,e,s,i){super(t,e),this.plugin=s,this.onSelect=i}getSuggestions(t){if(!t.trim())return[];let e=t.toLowerCase(),s=new Set(this.plugin.settings.excludePatterns),i=[];for(let n of this.plugin.app.vault.getAllLoadedFiles()){let r=n instanceof l.TFolder?n.path+"/":n.path;if(r.toLowerCase().includes(e)&&!s.has(r)&&(i.push(r),i.length>=20))break}return i}renderSuggestion(t,e){e.setText(t)}selectSuggestion(t,e){this.onSelect(t),this.setValue(""),this.close()}},q={serverUrl:"http://localhost:3000",username:"",password:"",autoSyncInterval:5,encryptionPassphrase:"",accessToken:"",refreshToken:"",userId:"",deviceId:"",encryptionSalt:"",lastSyncTime:0,excludePatterns:[],lastSyncedPaths:[]},K=class extends l.Modal{constructor(t,e){super(t),this.plugin=e}onOpen(){let{contentEl:t}=this;t.createEl("h2",{text:"Change Encryption Passphrase"}),t.createEl("p",{text:"Warning: this re-encrypts all files with the new passphrase. All other devices must update their passphrase before they can sync again.",attr:{style:"color: var(--text-muted); margin-bottom: 12px;"}});let e="",s="";new l.Setting(t).setName("New passphrase").addText(i=>{i.inputEl.type="password",i.setPlaceholder("Enter new passphrase\u2026"),i.onChange(n=>{e=n})}),new l.Setting(t).setName("Confirm passphrase").addText(i=>{i.inputEl.type="password",i.setPlaceholder("Confirm new passphrase\u2026"),i.onChange(n=>{s=n})}),new l.Setting(t).addButton(i=>i.setButtonText("Change Passphrase").setWarning().onClick(async()=>{if(!e){new l.Notice("CloudSync: Passphrase cannot be empty");return}if(e!==s){new l.Notice("CloudSync: Passphrases do not match");return}this.close();try{await this.plugin.changePassphrase(e),new l.Notice("CloudSync: Passphrase changed. Re-uploading all files\u2026")}catch(n){let r=n instanceof Error?n.message:String(n);new l.Notice(`CloudSync: Passphrase change failed \u2014 ${r}`)}})).addButton(i=>i.setButtonText("Cancel").onClick(()=>this.close()))}onClose(){this.contentEl.empty()}},x=class extends l.PluginSettingTab{constructor(t,e){super(t,e),this.plugin=e}display(){let{containerEl:t}=this;t.empty(),t.addClass("cloudsync-settings"),t.createEl("h2",{text:"CloudSync Settings"});let e=!!this.plugin.settings.accessToken;if(t.createDiv({cls:`connection-status ${e?"connected":"disconnected"}`}).setText(e?`Connected as ${this.plugin.settings.username} (Device: ${this.plugin.settings.deviceId.substring(0,8)}...)`:"Not connected"),t.createEl("h3",{text:"Server"}),new l.Setting(t).setName("Server URL").setDesc("The URL of your ObsidianCloudSync server").addText(a=>a.setPlaceholder("http://localhost:3000").setValue(this.plugin.settings.serverUrl).onChange(async o=>{this.plugin.settings.serverUrl=o.replace(/\/+$/,""),await this.plugin.saveSettings()})),t.createEl("h3",{text:"Authentication"}),new l.Setting(t).setName("Username").addText(a=>a.setPlaceholder("username").setValue(this.plugin.settings.username).onChange(async o=>{this.plugin.settings.username=o,await this.plugin.saveSettings()})),new l.Setting(t).setName("Password").addText(a=>{a.inputEl.type="password",a.setPlaceholder("password").setValue(this.plugin.settings.password).onChange(async o=>{this.plugin.settings.password=o,await this.plugin.saveSettings()})}),new l.Setting(t).setName("Account").addButton(a=>a.setButtonText("Login").onClick(async()=>{try{let o=await this.plugin.api.login();await this.plugin.handleVaultKeyFromAuth(o),new l.Notice("CloudSync: Logged in successfully"),this.display()}catch(o){let c=o instanceof Error?o.message:String(o);new l.Notice(`CloudSync: Login failed \u2014 ${c}`)}})).addButton(a=>a.setButtonText("Register").onClick(async()=>{try{await this.plugin.api.register(),new l.Notice("CloudSync: Registered and logged in"),this.display()}catch(o){let c=o instanceof Error?o.message:String(o);new l.Notice(`CloudSync: Registration failed \u2014 ${c}`)}})),e&&new l.Setting(t).setName("Session").setDesc("Clears stored tokens from this device").addButton(a=>a.setButtonText("Logout").setWarning().onClick(async()=>{try{await this.plugin.api.logout()}catch{}this.plugin.settings.accessToken="",this.plugin.settings.refreshToken="",this.plugin.settings.userId="",this.plugin.settings.deviceId="",await this.plugin.saveSettings(),this.plugin.wsClient?.disconnect(),new l.Notice("CloudSync: Logged out"),this.display()})),t.createEl("h3",{text:"Encryption"}),!!this.plugin.settings.encryptionSalt)new l.Setting(t).setName("Encryption").setDesc("Active \u2014 files are encrypted with AES-256-GCM before leaving this device. All synced devices use the same key.").addButton(a=>a.setButtonText("Change Passphrase").setWarning().onClick(()=>{new K(this.plugin.app,this.plugin).open()}));else{let a=this.plugin.settings.encryptionPassphrase?" Passphrase is set and will activate on the next sync.":"";new l.Setting(t).setName("Encryption passphrase").setDesc("Encrypt all files client-side before uploading. Leave empty to sync without encryption. All devices must use the same passphrase."+a).addText(o=>{o.inputEl.type="password",o.setPlaceholder("Enter a passphrase\u2026").setValue(this.plugin.settings.encryptionPassphrase).onChange(async c=>{this.plugin.settings.encryptionPassphrase=c,await this.plugin.saveSettings(),this.plugin.pushVaultKey()})})}t.createEl("h3",{text:"Sync"}),new l.Setting(t).setName("Auto-sync").setDesc("When to automatically sync changes to the server.").addDropdown(a=>a.addOption("0","Disabled").addOption("-1","Only on change").addOption("5","Every 5 minutes").addOption("10","Every 10 minutes").addOption("15","Every 15 minutes").addOption("30","Every 30 minutes").addOption("60","Every hour").setValue(String(this.plugin.settings.autoSyncInterval)).onChange(async o=>{this.plugin.settings.autoSyncInterval=parseInt(o,10),await this.plugin.saveSettings(),this.plugin.restartAutoSync()})),this.plugin.settings.lastSyncTime>0?new l.Setting(t).setName("Last sync").setDesc(new Date(this.plugin.settings.lastSyncTime).toLocaleString()).addButton(a=>a.setButtonText("Sync now").onClick(async()=>{await this.plugin.syncNow()})):new l.Setting(t).setName("Manual sync").addButton(a=>a.setButtonText("Sync now").onClick(async()=>{await this.plugin.syncNow()})),new l.Setting(t).setName("Directional sync").setDesc("Push: upload local files to server \u2014 local wins on conflicts, server changes are ignored. Pull: download server files to local \u2014 server wins on conflicts, local uploads are skipped. Use Push when you paste files locally that have older timestamps and don't want them overwritten.").addButton(a=>a.setButtonText("Push only").onClick(async()=>{await this.plugin.pushNow()})).addButton(a=>a.setButtonText("Pull only").onClick(async()=>{await this.plugin.pullNow()})),t.createEl("h3",{text:"Exclude from sync"});let n=t.createDiv({cls:"cloudsync-chip-list"});this.renderChips(n);let r;new l.Setting(t).setName("Add exclusion").setDesc("Search vault files and folders, or type a glob pattern (e.g. *.tmp) and press Enter.").addText(a=>{a.setPlaceholder("Search files and folders\u2026"),r=a,new L(this.app,a.inputEl,this.plugin,async o=>{await this.addPattern(o,n)}),a.inputEl.addEventListener("keydown",async o=>{if(o.key==="Enter"){let c=a.getValue().trim();c&&(await this.addPattern(c,n),a.setValue(""))}})})}async addPattern(t,e){this.plugin.settings.excludePatterns.includes(t)||(this.plugin.settings.excludePatterns.push(t),await this.plugin.saveSettings(),this.renderChips(e))}renderChips(t){if(t.empty(),this.plugin.settings.excludePatterns.length===0){t.createEl("div",{text:"No exclusions added.",cls:"cloudsync-chip-empty"});return}for(let e of[...this.plugin.settings.excludePatterns]){let s=t.createDiv({cls:"cloudsync-chip"});s.createEl("span",{text:e,cls:"cloudsync-chip-text"});let i=s.createEl("button",{cls:"cloudsync-chip-remove",text:"\xD7"});i.setAttribute("aria-label",`Remove ${e}`),i.addEventListener("click",async()=>{this.plugin.settings.excludePatterns=this.plugin.settings.excludePatterns.filter(n=>n!==e),await this.plugin.saveSettings(),this.renderChips(t)})}}};var A=class{constructor(t,e){this.state="idle";this.message="";this.progress="";this.plugin=t,this.statusBarEl=e,this.render()}setState(t,e){this.state=t,this.message=e||"",this.progress="",this.render()}setProgress(t,e,s){this.state="syncing",this.progress=`${t}/${e}`,this.message=s||"",this.render()}render(){this.statusBarEl.empty(),this.statusBarEl.addClass("cloudsync-status-bar"),this.statusBarEl.createSpan({cls:`sync-icon ${this.state}`}).setAttribute("aria-label",this.state);let e;switch(this.state){case"idle":this.plugin.settings.lastSyncTime>0?e=`Synced ${this.timeAgo(this.plugin.settings.lastSyncTime)}`:e="CloudSync: Ready";break;case"syncing":this.progress?e=`Syncing ${this.progress} files...`:e=this.message||"Syncing...";break;case"error":e=this.message||"Sync error";break}this.statusBarEl.createSpan({text:e})}timeAgo(t){let s=Date.now()-t,i=Math.floor(s/1e3);if(i<60)return"just now";let n=Math.floor(i/60);if(n<60)return`${n}m ago`;let r=Math.floor(n/60);return r<24?`${r}h ago`:`${Math.floor(r/24)}d ago`}};var d=require("obsidian");var $=class{constructor(t){this.syncing=!1;this.hashCache=new Map;this.dirty=!1;this.plugin=t}get isSyncing(){return this.syncing}get isDirty(){return this.dirty}markDirty(){this.dirty=!0}async sync(t=!1,e="bidirectional"){if(this.syncing){t||new d.Notice("CloudSync: Sync already in progress");return}if(!this.plugin.api.isLoggedIn()){t||new d.Notice("CloudSync: Not logged in. Please log in first.");return}this.syncing=!0,this.plugin.statusBar.setState("syncing","Building manifest...");try{let s=await this.buildManifest();this.plugin.statusBar.setState("syncing",`Checking ${s.length} files...`);let i=new Set(s.map(h=>h.path)),n=this.plugin.settings.lastSyncedPaths??[],r=[];if(n.length>0){let h=n.filter(P=>!i.has(P)),p=h.length/n.length;p<=.5?r.push(...h):console.warn(`CloudSync: ${h.length}/${n.length} tracked files appear deleted \u2014 ratio ${(p*100).toFixed(0)}% exceeds 50% threshold, skipping explicit deletes (treating as possible vault wipe; server will send Download instructions instead)`)}let a=e==="pull"?[]:r,o=await this.plugin.api.delta(s,a);await this.reconcileEncryptionSalt(o.encryption_salt);let c=e==="push"?o.instructions.filter(h=>h.action==="upload"||h.action==="conflict"):e==="pull"?o.instructions.filter(h=>h.action==="download"||h.action==="delete"||h.action==="conflict"):o.instructions;if(c.length===0){await this.plugin.api.complete(),this.plugin.settings.lastSyncTime=Date.now(),this.plugin.settings.lastSyncedPaths=s.map(h=>h.path),await this.plugin.saveSettings(),this.dirty=!1,this.plugin.statusBar.setState("idle");return}let g=0,y=0,b=0,S=0,D=0,_=0,E=c.length;for(let h=0;h<c.length;h++){let p=c[h];try{switch(p.action){case"upload":this.plugin.statusBar.setProgress(h+1,E,`Uploading: ${p.path}`),await this.withRetry(()=>this.handleUpload(p),p.path),g++;break;case"download":this.plugin.statusBar.setProgress(h+1,E,`Downloading: ${p.path}`),await this.handleDownload(p)&&y++;break;case"conflict":this.plugin.statusBar.setProgress(h+1,E,`Resolving conflict: ${p.path}`),e==="push"?(await this.withRetry(()=>this.handleUpload(p),p.path),g++):e==="pull"?await this.handleDownload(p)&&y++:(await this.handleConflict(p),S++);break;case"delete":this.plugin.statusBar.setProgress(h+1,E,`Deleting: ${p.path}`),await this.handleDelete(p),b++;break}}catch(P){D++,(p.action==="download"||p.action==="conflict")&&_++;let O=P instanceof Error?P.message:String(P),M=P.status,W=M?`[HTTP ${M}] `:"";console.error(`CloudSync: Error processing ${p.path}: ${W}${O}`)}}_===0?(await this.plugin.api.complete(),this.plugin.settings.lastSyncTime=Date.now(),this.plugin.settings.lastSyncedPaths=s.map(h=>h.path),await this.plugin.saveSettings(),this.dirty=!1):console.warn(`CloudSync: ${_} download(s) failed \u2014 skipping complete() so the sync cursor is not advanced. Will retry on next sync.`);let w=[];if(g>0&&w.push(`${g} uploaded`),y>0&&w.push(`${y} downloaded`),b>0&&w.push(`${b} deleted`),S>0&&w.push(`${S} conflicts`),D>0&&w.push(`${D} errors`),!t||w.length>0){let h=w.length>0?w.join(", "):"no changes",p=e==="push"?"Push":e==="pull"?"Pull":"Sync";new d.Notice(`CloudSync: ${p} complete (${h})`)}this.plugin.statusBar.setState("idle")}catch(s){let i=s instanceof Error?s.message:String(s);console.error("CloudSync: Sync failed:",i),new d.Notice(`CloudSync: Sync failed - ${i}`),this.plugin.statusBar.setState("error",`Error: ${i}`)}finally{this.syncing=!1}}async buildManifest(){let t=this.plugin.app.vault,e=t.getFiles(),s=[],i=new Set,n=0;for(let r of e){if(this.shouldSkip(r.path))continue;i.add(r.path);let a=Math.floor(r.stat.mtime/1e3),o=r.stat.size,c=this.hashCache.get(r.path);if(c&&c.mtime===a&&c.size===o){s.push({path:r.path,hash:c.hash,size:c.size,modified_at:a}),n++;continue}try{let g=await t.readBinary(r),y=await v(g);this.hashCache.set(r.path,{hash:y,mtime:a,size:g.byteLength}),s.push({path:r.path,hash:y,size:g.byteLength,modified_at:a})}catch(g){let y=g instanceof Error?g.message:String(g);console.warn(`CloudSync: Could not read ${r.path}: ${y}`)}}for(let r of this.hashCache.keys())i.has(r)||this.hashCache.delete(r);return console.log(`CloudSync: Manifest built \u2014 ${s.length} files, ${n} cached, ${s.length-n} hashed`),s}async handleUpload(t){let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);if(!(s instanceof d.TFile))throw new Error(`File not found in vault: ${t.path}`);let i=await e.readBinary(s),n=await v(i),r;this.isEncryptionEnabled()?r=await this.plugin.crypto.encrypt(i,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt):r=i,await this.plugin.api.upload(t.path,r,n)}async handleDownload(t){if(!t.file_id)throw new Error(`No file_id for download: ${t.path}`);if(this.plugin.settings.encryptionSalt&&!this.plugin.settings.encryptionPassphrase)throw new Error(`Cannot download "${t.path}" \u2014 server has encryption configured but no passphrase is set on this device. Enter your encryption passphrase in plugin settings.`);let e=await this.plugin.api.download(t.file_id),s;if(this.isEncryptionEnabled())try{s=await this.plugin.crypto.decrypt(e,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt)}catch(a){let o=await v(e),c=this.plugin.app.vault,g=(0,d.normalizePath)(t.path),y=c.getAbstractFileByPath(g);if(y instanceof d.TFile){let b=await c.readBinary(y),S=await v(b);if(S===o)return console.warn(`CloudSync: Decryption skipped for "${t.path}" \u2014 blob matches local content (uploaded before encryption was enabled). Fixing server hash.`),await this.plugin.api.fixHash(t.file_id,S),!1}if(t.server_hash&&o===t.server_hash)console.warn(`CloudSync: Using plaintext blob for "${t.path}" \u2014 file was uploaded before encryption was enabled.`),s=e;else throw a}else s=e;let i=this.plugin.app.vault,n=(0,d.normalizePath)(t.path),r=i.getAbstractFileByPath(n);if(r instanceof d.TFile){let a=await i.readBinary(r),o=await v(a),c=await v(s);return o===c?(await this.plugin.api.fixHash(t.file_id,o),!1):(await i.modifyBinary(r,s),!0)}return await this.ensureDirectory(n),await i.createBinary(n,s),!0}async handleConflict(t){if(t.file_id){let i=await this.plugin.api.download(t.file_id);this.isEncryptionEnabled()&&(i=await this.plugin.crypto.decrypt(i,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt));let n=this.makeConflictPath(t.path);await this.ensureDirectory(n);let r=this.plugin.app.vault,a=r.getAbstractFileByPath(n);a instanceof d.TFile?await r.modifyBinary(a,i):await r.createBinary(n,i),new d.Notice(`CloudSync: Conflict on "${t.path}" - server version saved as "${n}"`)}let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);if(s instanceof d.TFile){let i=await e.readBinary(s),n=await v(i),r=i;this.isEncryptionEnabled()&&(r=await this.plugin.crypto.encrypt(i,this.plugin.settings.encryptionPassphrase,this.plugin.settings.encryptionSalt)),await this.plugin.api.upload(t.path,r,n)}}async handleDelete(t){let e=this.plugin.app.vault,s=e.getAbstractFileByPath(t.path);s instanceof d.TFile&&await e.delete(s)}makeConflictPath(t){let e=new Date().toISOString().replace(/[:.]/g,"-").slice(0,19),s=t.lastIndexOf(".");if(s===-1)return`${t}.conflict-${e}`;let i=t.substring(0,s),n=t.substring(s);return`${i}.conflict-${e}${n}`}async ensureDirectory(t){let e=t.split("/");if(e.length<=1)return;let s=e.slice(0,-1).join("/"),i=this.plugin.app.vault;i.getAbstractFileByPath(s)||await i.createFolder(s)}shouldSkip(t){if(t.startsWith(".")||t==="data.json")return!0;for(let e of this.plugin.settings.excludePatterns)if(this.matchesPattern(t,e))return!0;return!1}matchesPattern(t,e){if(e.endsWith("/"))return t.startsWith(e)||t.startsWith(e.slice(0,-1));if(t===e)return!0;let s="^";for(let i=0;i<e.length;i++){let n=e[i];n==="*"&&e[i+1]==="*"?(s+=".*",i++,e[i+1]==="/"&&i++):n==="*"?s+="[^/]*":n==="?"||n==="."||n==="("||n===")"||n==="["||n==="]"||n==="{"||n==="}"||n==="+"||n==="^"||n==="$"||n==="|"||n==="\\"?s+="\\"+n:s+=n}s+="$";try{return new RegExp(s).test(t)}catch{return!1}}async withRetry(t,e,s=3){let i;for(let n=1;n<=s;n++)try{return await t()}catch(r){i=r;let a=r.status;if(a===401||a===403||a===404||a===413)throw r;if(n<s){let o=n*2e3;console.warn(`CloudSync: Upload attempt ${n} failed for ${e} \u2014 retrying in ${o/1e3}s`),await new Promise(c=>setTimeout(c,o))}}throw i}async reconcileEncryptionSalt(t){if(t)this.plugin.settings.encryptionSalt!==t&&(this.plugin.settings.encryptionSalt=t,this.plugin.crypto.clearCache(),await this.plugin.saveSettings());else if(this.plugin.settings.encryptionPassphrase){this.plugin.settings.encryptionSalt||(this.plugin.settings.encryptionSalt=this.plugin.crypto.generateSalt(),await this.plugin.saveSettings());try{await this.plugin.api.pushEncryptionSalt(this.plugin.settings.encryptionSalt),this.plugin.pushVaultKey()}catch{}}}isEncryptionEnabled(){return!!this.plugin.settings.encryptionPassphrase&&!!this.plugin.settings.encryptionSalt}};var B=class{constructor(t){this.ws=null;this.reconnectTimer=null;this.reconnectDelay=1e3;this.maxReconnectDelay=3e4;this.alive=!1;this.plugin=t}connect(){if(!this.plugin.api.isLoggedIn())return;let t=this.plugin.settings.serverUrl,e=this.plugin.settings.accessToken,i=`${t.replace(/^https:\/\//,"wss://").replace(/^http:\/\//,"ws://")}/api/ws?token=${encodeURIComponent(e)}`;try{this.ws=new WebSocket(i),this.alive=!0,this.ws.onopen=()=>{console.log("CloudSync WS: Connected"),this.reconnectDelay=1e3},this.ws.onmessage=n=>{this.handleMessage(n.data)},this.ws.onclose=n=>{console.log(`CloudSync WS: Closed (code=${n.code}, reason=${n.reason})`),this.ws=null,this.alive&&this.scheduleReconnect()},this.ws.onerror=()=>{console.warn("CloudSync WS: Connection error")}}catch(n){console.warn("CloudSync WS: Failed to connect:",n),this.scheduleReconnect()}}disconnect(){this.alive=!1,this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.ws&&(this.ws.close(),this.ws=null)}handleMessage(t){try{let e=JSON.parse(t);e.type==="sync_update"&&(console.log(`CloudSync WS: Sync update - ${e.action} ${e.file_path}`),this.plugin.syncEngine.isSyncing||setTimeout(()=>{this.plugin.syncEngine.isSyncing||this.plugin.syncNow()},2e3))}catch{}}scheduleReconnect(){this.alive&&(console.log(`CloudSync WS: Reconnecting in ${this.reconnectDelay/1e3}s...`),this.reconnectTimer=setTimeout(()=>{this.reconnectTimer=null,this.connect()},this.reconnectDelay),this.reconnectDelay=Math.min(this.reconnectDelay*2,this.maxReconnectDelay))}get isConnected(){return this.ws!==null&&this.ws.readyState===WebSocket.OPEN}};var R=class extends f.Plugin{constructor(e,s){super(e,s);this.autoSyncTimer=null;this.debouncedSync=(0,f.debounce)(()=>{this.api.isLoggedIn()&&!this.syncEngine.isSyncing&&this.syncEngine.sync(!0)},3e4,!0)}async onload(){console.log("CloudSync: Loading plugin"),await this.loadSettings(),this.api=new C(this),this.crypto=new k,this.syncEngine=new $(this),this.wsClient=new B(this);let e=this.addStatusBarItem();this.statusBar=new A(this,e),this.addSettingTab(new x(this.app,this)),this.addRibbonIcon("refresh-cw","CloudSync: Sync now",async()=>{await this.syncNow()}),this.addCommand({id:"cloudsync-sync-now",name:"Sync now (bidirectional)",callback:async()=>{await this.syncNow()}}),this.addCommand({id:"cloudsync-push-now",name:"Push now (upload local changes to server)",callback:async()=>{await this.pushNow()}}),this.addCommand({id:"cloudsync-pull-now",name:"Pull now (download server changes to local)",callback:async()=>{await this.pullNow()}}),this.addCommand({id:"cloudsync-view-status",name:"View sync status",callback:()=>{this.showSyncStatus()}});let s=i=>{i instanceof f.TFile&&!i.path.startsWith(".obsidian/")&&!this.syncEngine.isSyncing&&(this.syncEngine.markDirty(),this.settings.autoSyncInterval!==0&&this.debouncedSync())};this.registerEvent(this.app.vault.on("modify",s)),this.registerEvent(this.app.vault.on("create",s)),this.registerEvent(this.app.vault.on("delete",s)),this.registerEvent(this.app.vault.on("rename",s)),this.restartAutoSync(),this.api.isLoggedIn()&&(setTimeout(()=>{this.syncNow()},5e3),this.wsClient.connect())}async onunload(){console.log("CloudSync: Unloading plugin"),this.stopAutoSync(),this.wsClient.disconnect()}async loadSettings(){this.settings=Object.assign({},q,await this.loadData())}async saveSettings(){await this.saveData(this.settings)}async syncNow(){await this.syncEngine.sync()}async pushNow(){await this.syncEngine.sync(!1,"push")}async pullNow(){await this.syncEngine.sync(!1,"pull")}showSyncStatus(){let e=this.settings,s=[];this.api.isLoggedIn()?(s.push(`Logged in as: ${e.username}`),s.push(`Device ID: ${e.deviceId.substring(0,8)}...`)):s.push("Not logged in"),e.lastSyncTime>0?s.push(`Last sync: ${new Date(e.lastSyncTime).toLocaleString()}`):s.push("Never synced");let i=e.autoSyncInterval===-1?"only on change":e.autoSyncInterval===0?"disabled":`every ${e.autoSyncInterval} min`;s.push(`Auto-sync: ${i}`),s.push(`Encryption: ${e.encryptionPassphrase?"enabled":"disabled"}`),this.syncEngine.isSyncing?s.push("Status: Syncing..."):s.push("Status: Idle"),new f.Notice(s.join(`
`),1e4)}restartAutoSync(){if(this.stopAutoSync(),this.settings.autoSyncInterval>0){let e=this.settings.autoSyncInterval*60*1e3;this.autoSyncTimer=setInterval(async()=>{this.api.isLoggedIn()&&!this.syncEngine.isSyncing&&this.syncEngine.isDirty&&await this.syncEngine.sync(!0)},e)}}stopAutoSync(){this.autoSyncTimer!==null&&(clearInterval(this.autoSyncTimer),this.autoSyncTimer=null)}async changePassphrase(e){let s=this.crypto.generateSalt();this.settings.encryptionPassphrase=e,this.settings.encryptionSalt=s,this.crypto.clearCache(),this.settings.lastSyncTime=0,await this.saveSettings(),await this.api.pushEncryptionSalt(s,!0),await this.pushVaultKey(),await this.syncNow()}async pushVaultKey(){let{encryptionPassphrase:e,password:s,username:i}=this.settings;if(!(!e||!s||!i))try{let n=await U(s,i),r=await V(e,n);await this.api.setVaultKey(r)}catch(n){console.warn("CloudSync: Could not push vault key:",n)}}async handleVaultKeyFromAuth(e){if(!e.encrypted_vault_key||this.settings.encryptionPassphrase)return;let{password:s,username:i}=this.settings;if(!(!s||!i))try{let n=await U(s,i),r=await H(e.encrypted_vault_key,n);this.settings.encryptionPassphrase=r,await this.saveSettings(),new f.Notice("CloudSync: Encryption passphrase loaded from account \u2014 encryption is active.")}catch(n){console.warn("CloudSync: Could not decrypt vault key (wrong password?):",n)}}};
